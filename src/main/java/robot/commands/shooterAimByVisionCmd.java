// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package robot.commands;
import javax.lang.model.util.ElementScanner6;

import edu.wpi.first.wpilibj.command.Command;
import robot.Robot;

/**
 *
 */
public class shooterAimByVisionCmd extends Command {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

        private int m_mode;
        private double m_timeout;
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    String line = "";
    boolean kill = false;
    private double targetX, targetY, targetDistance;
    private double  currentHoodPosition, targetHoodPosition, deltaHoodPosition;

    private static final double TARGET_X_DEADBAND = 0.75;      // TODO Change this number to get tighter
    private static final double HOOD_DEADBAND = 0.03;        // hood pot position deadband 

    private static double visionTgtBearing = 0;
    private static double visionTgtYangle = 0;
    private static double visionTgtDistance = 0;
    
    private static double lidarDoistance = 0;
    private static double currentHoodAngle = 0;
    private static double targetHoodAngle = 0;

    private enum RotateStatus {ROTATING, ONTARGET, DONE};
    private RotateStatus rotateStatus = RotateStatus.DONE;

    private enum HoodStatus {MOVING, ONTARGET, DONE};
    private HoodStatus hoodStatus = HoodStatus.DONE;


    // *************************************************************
    //                  Turret Data
    // fully Extended raises ball for a closer target
    // 112 inches distance to goal - Pot 4.99  for a ctr shot    ie) fully extended for CLOS Goal
    // 
    // fully Retracted lowers ball for a farther target
    // 380 inches distance to goal - Pot 0.0049 for a ctr shot   ie) fully retracted for Further Goal
    //
    //       Distance      Hood Pot     (9000 RPM Target)
    //      min travel      0.0049
    //
    //      380 inches      0.005
    //      277 inches      0.152
    //      225 inches      0.946
    //      177 inches      1.33
    //      144 inches      2.49
    //      120 inches      3.2
    //      112 inches      4.99
    //
    //      max travel      5.0  
    //  
    //      Autonomous Line shot set to 3.6 hood pot (between 112 inches and 120 inches)
    //
    
    private static final double HOOD_EXTENDED_MIN = 0.005; //4.8;        // measured 4.85 
    private static final double HOOD_RETRACTED_MAX = 4.8; // 0.005;     // measured 0.005
    private static final double MAX_SHOOTING_DISTANCE = 380;    // measired at this distance
    private static final double MIN_SHOOTING_DISTANCE = 112;    // measured at this distance

    private double currHoodPos = 0;
    private final double MOVESPEED = 0.3;

    // *************************************************************

    private enum TurretRotateState {ROTATING_RIGHT, ROTATING_LEFT, DONE};
    private TurretRotateState turretRotateState  = TurretRotateState. DONE;

    private enum TurretHoodState {MOVING, DONE};
    private TurretHoodState turretHoodState  = TurretHoodState. DONE;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public shooterAimByVisionCmd(int mode, double timeout) {

            m_mode = mode;
            m_timeout = timeout;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING5

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.shooterSubSys);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }


    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
        line = "shooterAimByVisionCmd starting up !";
        System.out.println(line);
        Robot.logger.appendLog(line); 
        turretHoodState  = TurretHoodState. DONE;       // init to done
        turretRotateState  = TurretRotateState. DONE;   // init to done

        if(m_mode != 0 ) {
            // were not running by Joystick so well use timeout to terminate the command
            setTimeout(m_timeout);
            rotateStatus = RotateStatus.DONE;
            hoodStatus = HoodStatus.DONE;
        }
    }


    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
        
        // *********************** Process Turret Rotate to Target ************************    
        proccesAutoTurretRotate();
    
        // *********************** Process Turret Hood to Target ************************
        proccesAutoHood();                           
    }


    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
        if(m_mode != 0 ) {
            // were not running by Joystick so well use timeout and status to terminate the command
            if (isTimedOut()) {
                line = "shooterAimByVisionCmd has Timedout !!";
                System.out.println(line);
                Robot.logger.appendLog(line); 
                return true;
            }
            if (( rotateStatus == RotateStatus.DONE ) && (hoodStatus == HoodStatus.DONE)) {
                // auto vision has completed it alignment
                line = "shooterAimByVisionCmd has completed RotateStatus and HoodStatus == Done !";
                System.out.println(line);
                Robot.logger.appendLog(line); 
                return true;
            }
        } 
       
        return false;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
        Robot.shooterSubSys.turretRotateMotorStop();
        Robot.shooterSubSys.turretHoodMotorStop();
        line = "shooterAimByVisionCmd ended !";
        System.out.println(line);
        Robot.logger.appendLog(line); 
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
        end();
    }

    // -----------------------------------------------------------------------
    //                       Hood Methods 
    // -----------------------------------------------------------------------

    private void proccesAutoHood(){
        targetDistance = Robot.shooterSubSys.getLidarDistance();
        //targetDistance = Robot.udpSubSys.getVisionDistance();

        if (targetDistance == 0){ 
            // We DO NOT have valid distance so stop motor and exit
            Robot.shooterSubSys.turretHoodMotorStop();
            line = "No valid distance data";
            Robot.logger.appendLog(line);
            System.out.println(line); 
            hoodStatus = HoodStatus.DONE;
            return;
        }

        if ( targetDistance < 80 ) {
            // We are too close to wall so we need to go for low shot
            targetHoodPosition = HOOD_EXTENDED_MIN;
        } else {
            targetHoodPosition = calcHoodPosition(); // This is based on distance
        }

        setHoodMotorForPosition();
    }


    // ---------------- HoodPosition --------------
    private double calcHoodPosition(){

        //Polynomial 3 ... Data 3 - Lower RPM with Foam Insert
        double a = 38.47744;
        double b = -0.57205 * targetDistance;
        double c = 0.00287 * (Math.pow(targetDistance, 2));
        double d = -4.8439e-6 * (Math.pow(targetDistance, 3));
        double calcHoodPotPos = a +  b + c + d;

        // Polynomial 4 ..... Data 1 & 2
        // double a = 42.4598147;
        // double b = -0.700867613 * targetDistance;
        // double c = 0.004473933 * (Math.pow(targetDistance, 2));
        // double d = -1.2452003e-5 * (Math.pow(targetDistance, 3));
        // double e = 1.252171206e-8 * (Math.pow(targetDistance, 4));
        //double calcHoodPotPos = a +  b + c + d  + e;

        // prevent overdriving position
        if(calcHoodPotPos < HOOD_EXTENDED_MIN)   {   calcHoodPotPos = HOOD_EXTENDED_MIN; }
        if(calcHoodPotPos > HOOD_RETRACTED_MAX)  {   calcHoodPotPos = HOOD_RETRACTED_MAX;  }
        return calcHoodPotPos;
    }
 
    private void setHoodMotorForPosition(){
        currHoodPos = Robot.shooterSubSys.getHoodPot();

        double moveSpeed = Robot.shooterSubSys.calcHoodMotorForPosition( currHoodPos, targetHoodPosition, HOOD_DEADBAND);
        
        if ( moveSpeed == 0 ) {
            // we have reached our target so time to end
            Robot.shooterSubSys.turretHoodMotorStop();
            line = ("shooterAimByVisionCmd Hood Reached target position!  CurrPosition=" + currHoodPos +
                    "  targetHoodPosition=" + targetHoodPosition +
                    "  Hood target Distance(Lidar)=" + targetDistance);
            Robot.logger.appendLog(line);
            System.out.println(line); 
            hoodStatus = HoodStatus.DONE;
            return;
        }

        Robot.shooterSubSys.turretHoodMotorSet( moveSpeed, false);
        line = ("shooterAimByVisionCmd Hood Moving!  CurrPosition=" + currHoodPos +
            "  targetHoodPosition=" + targetHoodPosition +
            "  Hood target Distance(Lidar)=" + targetDistance);
        Robot.logger.appendLog(line);
        hoodStatus = HoodStatus.MOVING;
        System.out.println(line);
    }

    
    // -----------------------------------------------------------------------
    //                   Vision Driven Turret Rotate Methods 
    // -----------------------------------------------------------------------

    private void proccesAutoTurretRotate(){
        // ************************ Turret Rotate by Vision ***********************
        double turretRotateSpeed = 0;
        currentHoodAngle = Robot.shooterSubSys.getRotateAngle();

        if (Robot.udpSubSys.isValidVisionTarget() == true) {
            // We have a valid target in sight so lets update our target data
            visionTgtBearing = Robot.udpSubSys.getXangle();    
            targetHoodAngle = currentHoodAngle + visionTgtBearing;
            visionTgtYangle = Robot.udpSubSys.getYangle();
            visionTgtDistance = Robot.udpSubSys.getVisionDistance();
            line = ("We have a valid vision Target XAngle=" + visionTgtBearing +
                     " VisionTgtDistance=" + visionTgtDistance +
                     " VisionTgtYangle=" + visionTgtYangle);
            Robot.logger.appendLog(line); 
        } else {
            // No Valid vision target
            visionTgtBearing = 0;    
            visionTgtYangle = 0;
            visionTgtDistance = 0;
        }

        // Were not done yet
        turretRotateSpeed = Robot.shooterSubSys.calcRotateMotorForPosition(currentHoodAngle, targetHoodAngle, TARGET_X_DEADBAND);
        if (turretRotateSpeed == 0) {
            // were done
            Robot.shooterSubSys.turretRotateMotorStop(); 
            turretRotateState = TurretRotateState.DONE;
            return;
        }

        // send power to motor
        Robot.shooterSubSys.turretRotateMotorSet(turretRotateSpeed, false);
        rotateStatus = RotateStatus.ROTATING;
        line = ("We are rotating to our Target " +
                " CurrentHoodAngle=" + currentHoodAngle +
                " targetHoodAngle=" + targetHoodAngle +
                " TurretRotateSpeed= " + turretRotateSpeed);
        System.out.println(line);
        Robot.logger.appendLog(line); 
    }

}
