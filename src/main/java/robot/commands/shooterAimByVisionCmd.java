// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package robot.commands;
import javax.lang.model.util.ElementScanner6;

import edu.wpi.first.wpilibj.command.Command;
import robot.Robot;

/**
 *
 */
public class shooterAimByVisionCmd extends Command {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    private double targetX, targetY, targetDistance;
    private double  currentHoodPosition, targetHoodPosition, deltaHoodPosition;

    private static final double TARGET_X_DEADBAND = 1;      // TODO Change this number to get tighter
    private static final double HOOD_DEADBAND = 0.1;        // hood pot position deadband 

    private static final double HOOD_RETRACT_MIN = 1.2;     // Hood Pot when fully retracted
    private static final double HOOD_EXTEND_MAX = 3.5;      // Hood Pot when fully extended
    private static final double MIN_SHOOTING_DISTANCE = 96;    // Minmum distance for a center shot at full extendion
    private static final double MAX_SHOOTING_DISTANCE = 420;   // Maximum distance for a center shot at full rettaction
    private static final double SHOOTING_SLOPE =
             (HOOD_EXTEND_MAX - HOOD_RETRACT_MIN) / ( MAX_SHOOTING_DISTANCE - MIN_SHOOTING_DISTANCE);
    private static final double SHOOTING_Y_INTERCEPT = (SHOOTING_SLOPE * MIN_SHOOTING_DISTANCE) + HOOD_RETRACT_MIN;

    private enum TurretRotateState {MOVING, DONE};
    private TurretRotateState turretRotateState  = TurretRotateState. DONE;

    private enum TurretHoodState {MOVING, DONE};
    private TurretHoodState turretHoodState  = TurretHoodState. DONE;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public shooterAimByVisionCmd() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.shooterSubSys);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {

        // Bring fly wheel up to speed and leave running ???????
        //Robot.shooterSubSys.flywheelSetOn(Robot.shooterSubSys.HIGH_GOAL_SPEED, Robot.shooterSubSys.HIGH_GOAL); 
        //System.out.println("shooterAimByVisionCmd starting up !");
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {       

        if (Robot.udpSubSys.isValidVisionTarget() == false) {
            Robot.shooterSubSys.turretRotateMotorStop();
            Robot.shooterSubSys.turretHoodMotorStop();
            return;
        }
        // We have a target in sight so continue !
        

        // *********************** Process Turret Rotate to Target ************************

        targetX = Robot.udpSubSys.getXangle();

        if (targetX >= Math.abs(TARGET_X_DEADBAND)) {
            // were not centered on target yet !
            turretRotateState = TurretRotateState.MOVING;
            if (targetX > 0) {
                // we need to turn to the right
                if      (targetX >= 20.0) { Robot.shooterSubSys.turretHoodMotorSet(0.7 , false); }
                else if (targetX >= 10.0) { Robot.shooterSubSys.turretHoodMotorSet(0.5, false); }
                else if (targetX >= 5.0)  { Robot.shooterSubSys.turretHoodMotorSet(0.4, false); }
                else if (targetX >= 2.5)  { Robot.shooterSubSys.turretHoodMotorSet(0.2, false); }
            } else {
                // we need to turn to the left
                if      (targetX <= -20.0) { Robot.shooterSubSys.turretHoodMotorSet(0.7, false); } 
                else if (targetX <= -10.0) { Robot.shooterSubSys.turretHoodMotorSet(0.5, false); }
                else if (targetX <= -5.0)  { Robot.shooterSubSys.turretHoodMotorSet(0.4, false); }
                else if (targetX <= -2.5)  { Robot.shooterSubSys.turretHoodMotorSet(0.2, false); }
            }
        } else {
            // we are centered on target
            Robot.shooterSubSys.turretRotateMotorStop();
            turretRotateState = TurretRotateState.DONE;
        }

        
        
        // *********************** Process Turret Hood to Target ************************
        
        targetDistance = Robot.udpSubSys.getLidarDistance();

        if (targetDistance == 0){
            // we dont have valid distance data so just get out
            return;
         }

        currentHoodPosition = Robot.shooterSubSys.getHoodPot();

        // This based on a linear formula for distance to hood angle
        targetHoodPosition = (SHOOTING_SLOPE * targetDistance) + SHOOTING_Y_INTERCEPT;
        
        deltaHoodPosition = targetHoodPosition - currentHoodPosition;
        if (Math.abs(deltaHoodPosition) < HOOD_DEADBAND) {
            // Were done the is close to fhe final position
            Robot.shooterSubSys.turretHoodMotorStop();
            turretHoodState = TurretHoodState.DONE;
            return;
        }

        turretHoodState = TurretHoodState.MOVING;

        if (deltaHoodPosition > 0) {
            // we need to extend turrent more, as we get closer move more slowly
            if      ( deltaHoodPosition > 1.0)    Robot.shooterSubSys.turretHoodMotorSet(0.5, false);
            else if (deltaHoodPosition > 0.7)     Robot.shooterSubSys.turretHoodMotorSet(0.4, false);
            else if (deltaHoodPosition > 0.5)     Robot.shooterSubSys.turretHoodMotorSet(0.3, false);
            else if (deltaHoodPosition > 0.4)     Robot.shooterSubSys.turretHoodMotorSet(0.2, false);
            else                                  Robot.shooterSubSys.turretHoodMotorSet(0.1, false);
        }else {
            // We need to retract hood more as, we get closer move more slowly
            if      ( deltaHoodPosition < -1.0)    Robot.shooterSubSys.turretHoodMotorSet( -0.5, false);
            else if (deltaHoodPosition < -0.7)     Robot.shooterSubSys.turretHoodMotorSet( -0.4, false);
            else if (deltaHoodPosition < -0.5)     Robot.shooterSubSys.turretHoodMotorSet( -0.3, false);
            else if (deltaHoodPosition < -0.4)     Robot.shooterSubSys.turretHoodMotorSet( -0.2, false);
            else                                  Robot.shooterSubSys.turretHoodMotorSet( -0.1, false);

        }

    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
        if ((turretHoodState == TurretHoodState.DONE) && ( turretRotateState == TurretRotateState.DONE)) {
            return true;
        }

        // ?????? when is this command done .... xAngle = 0 and hood pot is aligned with lidar distance
        // ?????? keep tracking as we move
        // ?????? toggle on and off ...
        return false;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
        Robot.shooterSubSys.turretRotateMotorStop();
        Robot.shooterSubSys.turretHoodMotorStop();
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
        end();
    }
}
