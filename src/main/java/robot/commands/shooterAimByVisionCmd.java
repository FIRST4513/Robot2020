// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package robot.commands;
import javax.lang.model.util.ElementScanner6;

import edu.wpi.first.wpilibj.command.Command;
import robot.Robot;

/**
 *
 */
public class shooterAimByVisionCmd extends Command {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    private double targetX, targetY, targetDistance;
    private double  currentHoodPosition, targetHoodPosition, deltaHoodPosition;

    private static final double TARGET_X_DEADBAND = 1;      // TODO Change this number to get tighter
    private static final double HOOD_DEADBAND = 0.01;        // hood pot position deadband 



    // *************************************************************
    //                  Turret Data
    // fully Extended raises ball for a closer target
    // 112 inches distance to goal - Pot 4.99  for a ctr shot    ie) fully extended for CLOS Goal
    // 
    // fully Retracted lowers ball for a farther target
    // 380 inches distance to goal - Pot 0.0049 for a ctr shot   ie) fully retracted for Further Goal
    //

    
    private static final double HOOD_EXTENDED_MAX = 4.8;        // measured 4.85 
    private static final double HOOD_RETRACTED_MIN = 0.005;     // measured 0.005
    private static final double MAX_SHOOTING_DISTANCE = 380;    // measired at this distance
    private static final double MIN_SHOOTING_DISTANCE = 112;    // measured at this distance

    //private static double hoodExtendedMax;
    //private static double hoodRetractedMin;
    //private double hoodRange;
    //private static double shootingSlope;
    //private static double shooting_Y_Intercept;

    private static final double HOOD_RANGE = HOOD_EXTENDED_MAX - HOOD_RETRACTED_MIN;
    //private static final double HOOD_RAISE_SPEED = 0.5;
    //private static final double HOOD_LOWER_SPEED = -0.5;

    private static final double SHOOTING_SLOPE =
        (HOOD_EXTENDED_MAX - HOOD_RETRACTED_MIN) / ( MAX_SHOOTING_DISTANCE - MIN_SHOOTING_DISTANCE);
    
    private static final double SHOOTING_Y_INTERCEPT = (SHOOTING_SLOPE * MIN_SHOOTING_DISTANCE) + HOOD_RETRACTED_MIN;

    private double currHoodPos = 0;

    private final double MOVESPEED = 0.3;

    private enum HoodDirState {RAISE, LOWER, DONE};
    private HoodDirState hoodDirState = HoodDirState.DONE;

    // *************************************************************

    private enum TurretRotateState {MOVING, DONE};
    private TurretRotateState turretRotateState  = TurretRotateState. DONE;

    private enum TurretHoodState {MOVING, DONE};
    private TurretHoodState turretHoodState  = TurretHoodState. DONE;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public shooterAimByVisionCmd() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING5

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.shooterSubSys);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
        System.out.println("shooterAimByVisionCmd starting up !");
    
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {    
        
        double kill = 0;
        if (kill == 0) return; // we dont want to rn this even on accident 
         
        // *********************** Process Turret Hood to Target ************************
        targetDistance = Robot.udpSubSys.getLidarDistance();
        if (targetDistance <= 0){
            // we dont have valid distance data so just get out
            return;
         }

        currentHoodPosition = Robot.shooterSubSys.getHoodPot();
        targetHoodPosition = calcHoodPosition(); // This based on a linear formula for distance to hood angle
        
        determineHoodDir();
        setHoodMotorForPosition();
        System.out.println("Hood target Dist=" + targetDistance + "   currentHoodPosition=" + currentHoodPosition + " targetHoodPosition=" + targetHoodPosition );



        // ******************************** Turret Rotate by Vision ***********************
        
        if (Robot.udpSubSys.isValidVisionTarget() == false) {
            Robot.shooterSubSys.turretRotateMotorStop();
            return;
        }
        // We have a target in sight so continue !

        targetX = Robot.udpSubSys.getXangle();

        if (targetX >= Math.abs(TARGET_X_DEADBAND)) {
            // were not centered on target yet !
            turretRotateState = TurretRotateState.MOVING;
            if (targetX > 0) {
                // we need to turn to the right
                if      (targetX >= 20.0) { Robot.shooterSubSys.turretHoodMotorSet(0.7 , false); }
                else if (targetX >= 10.0) { Robot.shooterSubSys.turretHoodMotorSet(0.5, false); }
                else if (targetX >= 5.0)  { Robot.shooterSubSys.turretHoodMotorSet(0.4, false); }
                else if (targetX >= 2.5)  { Robot.shooterSubSys.turretHoodMotorSet(0.2, false); }
            } else {
                // we need to turn to the left
                if      (targetX <= -20.0) { Robot.shooterSubSys.turretHoodMotorSet(0.7, false); } 
                else if (targetX <= -10.0) { Robot.shooterSubSys.turretHoodMotorSet(0.5, false); }
                else if (targetX <= -5.0)  { Robot.shooterSubSys.turretHoodMotorSet(0.4, false); }
                else if (targetX <= -2.5)  { Robot.shooterSubSys.turretHoodMotorSet(0.2, false); }
            }
        } else {
            // we are centered on target
            Robot.shooterSubSys.turretRotateMotorStop();
            turretRotateState = TurretRotateState.DONE;
        }


    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
        // Run while button is pressed
        
        //if ((turretHoodState == TurretHoodState.DONE) && ( turretRotateState == TurretRotateState.DONE)) {
        //    return true;
        //}

        // ?????? when is this command done .... xAngle = 0 and hood pot is aligned with lidar distance
        // ?????? keep tracking as we move
        // ?????? toggle on and off ...
        return false;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
        Robot.shooterSubSys.turretRotateMotorStop();
        Robot.shooterSubSys.turretHoodMotorStop();
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
        end();
    }

    private double calcHoodPosition(){
        // Linear straight line equation
        //double calcHoodPotPos = (SHOOTING_SLOPE * targetDistance ) + SHOOTING_Y_INTERCEPT;

        // Polynomial 2
        double a = 9.74497022;
        double b = -0.0609462251;
        double c = 9.3624588;

        //double calcHoodPotPos = a*(Math.pow(targetDistance,0)) +  b*(Math.pow(targetDistance,1)) + c*(Math.pow(targetDistance,2));
        double calcHoodPotPos = a +  b + c*(Math.pow(targetDistance,2));

        // prevent overdriving position
        if(calcHoodPotPos < HOOD_RETRACTED_MIN) {
            calcHoodPotPos = HOOD_RETRACTED_MIN;
        }
        if(calcHoodPotPos > HOOD_EXTENDED_MAX) {
            calcHoodPotPos = HOOD_EXTENDED_MAX;
        }

        return calcHoodPotPos;
    }

    public void determineHoodDir(){
        if (currHoodPos == targetHoodPosition) {
            hoodDirState = HoodDirState.DONE;
            System.out.println("State = Done !");
        }

        if (currHoodPos > targetHoodPosition) {
            hoodDirState = HoodDirState.RAISE;
            System.out.println("State = RAISE !");
            // Raise power = +
        } else {
            hoodDirState = HoodDirState.LOWER;
            System.out.println("State = LOWER !");
            // Lowere power = -
        }
    }

    private void setHoodMotorForPosition(){
        //System.out.println("Hood to pos CurrPos=" + currHoodPos);

        if (hoodDirState == HoodDirState.RAISE){
            if (currHoodPos > targetHoodPosition) {
                // Continue Raising 
                Robot.shooterSubSys.turretHoodMotorSet( -MOVESPEED, false);
                return;
            } else {
                // we have reached our target
                System.out.println("State = Done !");
                hoodDirState = HoodDirState.DONE;
                return;
            }
        }

        if (hoodDirState == HoodDirState.LOWER){
            if (currHoodPos < targetHoodPosition) {
                // Continue Lowereing
                Robot.shooterSubSys.turretHoodMotorSet( MOVESPEED, false);
                return;
            } else {
                // we have reached our target
                System.out.println("State = Done !");
                hoodDirState = HoodDirState.DONE;
                return;
            }
        }
    }


}
