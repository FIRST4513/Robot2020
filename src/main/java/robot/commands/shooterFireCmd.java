// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package robot.commands;

//import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import robot.Robot;
//import robot.Robot.JoystickStatus;
import robot.subsystems.intakeSubSys.MixerByShooterState;
import robot.subsystems.shooterSubSys.FlywheelSpeedState;
import robot.subsystems.shooterSubSys.FlywheelState;
//import robot.subsystems.shooterSubSys.GoalTarget;
import robot.subsystems.shooterSubSys.FlywheelGoalTarget;

//import robot.subsystems.shooterSubSys.FlywheelSpeedState;

public class shooterFireCmd extends Command {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    //private static final double HIGH_GOAL_SPEED = 9000.0;
    //private static final double LOW_GOAL_SPEED = 3500.0;
    //private static final double PID_FIRE_DELTA = 100.0;     // The range +- OK to Fire

    //private static final boolean LOW_GOAL = false;
    //private static final boolean HIGH_GOAL = true;

    private enum GoalTarget {HIGH, LOW};
    private GoalTarget goalTarget = GoalTarget.HIGH;

    private double targetRPM = Robot.shooterSubSys.HIGH_GOAL_SPEED;  // default to high goal

    private enum ShooterState { UP_TO_SPEED, UNDER_SPEED, FEEDING }
    ShooterState shooterState = ShooterState.UNDER_SPEED;

    // private static final double SHOOTER_SPEED = 5200; // In RPM
    // private static final double SHOOTER_PWR = 0.65;
    // private static final double RPM_DEADBAND = 100;

    private static final int SHOOTER_LOW_GOAL_BTN = 10;
    private static final int MANUAL_OVERIDE_BTN = 7;
    private boolean overide = false;

    private int m_mode = 0;
    private double m_timeout = 0;

    // --------- Handoff Motor variables ------
    private static final double  HANDOFF_MOTOR_FEED_SPEED = 1.0;


    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public shooterFireCmd(int mode, double timeout) {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        m_mode = mode;
        m_timeout = timeout;

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
        if (m_mode == 0) {
            // fire by joystick no timeout
        } else {
            // fire by atonomous
            setTimeout(m_timeout);
            System.out.println("**** Autonomous Firing -------- Shooting Goal");
            System.out.println("**** Autonomous Firing -------- Starting RPM ="+ Robot.shooterSubSys.getFlywheelRPM());
        }
            

        // look to see if the flywheel is already up to speed
        // default target is high speed if not already engaged

        if (Robot.shooterSubSys.getFlywheelState() != FlywheelState.ON) {
            // no pre spin up done so assume High target since this is used mostly
            goalTarget = GoalTarget.HIGH;
            targetRPM = Robot.shooterSubSys.HIGH_GOAL_SPEED;
            Robot.shooterSubSys.flywheelSetOn(targetRPM, Robot.shooterSubSys.HIGH_GOAL); 
            System.out.println("Shooting High Goal");
            return;
        }

        
        if (Robot.shooterSubSys.getFlywheelTarget() == FlywheelGoalTarget.HIGH) {
            targetRPM = Robot.shooterSubSys.HIGH_GOAL_SPEED;
        } else {
            targetRPM = Robot.shooterSubSys.LOW_GOAL_SPEED;
        }

        if ( Robot.oi.coDriverJoystick.getRawButton(MANUAL_OVERIDE_BTN) == true) {
            overide = true;
            System.out.println("Overide button pressed");
        } else {
            overide = false;
        }
        SmartDashboard.putNumber("Fire Delta RPM", Robot.shooterSubSys.PID_FIRE_DELTA);
        
        shooterState = ShooterState.UNDER_SPEED; // were just starting
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
        double currentRPM = Robot.shooterSubSys.getFlywheelRPM();
        double delta = currentRPM-targetRPM;

        overide = Robot.oi.coDriverJoystick.getRawButton(MANUAL_OVERIDE_BTN);      

        if (goalTarget == GoalTarget.LOW) {
            // were going for low gear
            if (shooterState == ShooterState.UNDER_SPEED) {
                // were not up to speed yet
                if ((currentRPM > (targetRPM-1000)) || (overide)) {
                    // we have made it up to speed
                    shooterState = ShooterState.UP_TO_SPEED;
                    
                } else {
                    // we have not made it up to speed yet so get out
                    return;
                }
            }
            // were here because we are up to speed on low goal
            Robot.shooterSubSys.handoffMotorSet(HANDOFF_MOTOR_FEED_SPEED);
            Robot.intakeSubSys.mixerByShooterState = MixerByShooterState.FEED;
            return;
        } // end of low goal
        
        // High Goal
        if (((Math.abs(delta) < Robot.shooterSubSys.PID_FIRE_DELTA)) || (overide)) {
            // were up to speed good to fire
            Robot.shooterSubSys.handoffMotorSet(HANDOFF_MOTOR_FEED_SPEED );
            Robot.intakeSubSys.mixerByShooterState = MixerByShooterState.FEED;
        } else {
            // were not in speed 
            Robot.shooterSubSys.handoffMotorStop();
            Robot.intakeSubSys.mixerByShooterState = MixerByShooterState.STOP;
            }
        }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
        if ((m_mode != 0) && (isTimedOut())){
            // we are shooting by auto we have timedout so end command
            return true;
        }
        
        return false;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
        //Robot.shooterSubSys.flywheelSetOff();
        Robot.shooterSubSys.handoffMotorStop();
        Robot.intakeSubSys.setMixerByShooterState(MixerByShooterState.STOP);
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
        end();
    }
}
