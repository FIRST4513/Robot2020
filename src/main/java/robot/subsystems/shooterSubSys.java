// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package robot.subsystems;

import robot.commands.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import com.revrobotics.CANEncoder;
import com.revrobotics.CANPIDController;
import com.revrobotics.CANSparkMax;
import com.revrobotics.ControlType;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;
import edu.wpi.first.wpilibj.AnalogPotentiometer;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.PWMVictorSPX;
import edu.wpi.first.wpilibj.SpeedController;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
    
public class shooterSubSys extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    public final double HIGH_GOAL_SPEED = 9000.0;
    public final double LOW_GOAL_SPEED = 3500.0;
    public final double PID_FIRE_DELTA = 100.0;     // The range +- OK to Fire

    public final boolean LOW_GOAL = false;
    public final boolean HIGH_GOAL = true;
    
    private double displayCnt = 3;

    // *************************************************************
    //                  Turret Data
    // fully Extended raises ball for a closer target
    // 112 inches distance to goal - Pot 4.99  for a ctr shot    ie) fully extended for CLOS Goal
    // 
    // fully Retracted lowers ball for a farther target
    // 380 inches distance to goal - Pot 0.0049 for a ctr shot   ie) fully retracted for Further Goal
    //
    private static final double HOOD_EXTENDED_MAX = 4.8;    // measured 4.85 
    private static final double HOOD_RETRACTED_MIN = 0.005;    // measured 0.005
    private static final double HOOD_RANGE = HOOD_EXTENDED_MAX - HOOD_RETRACTED_MIN;
    private static final double HOOD_RAISE_SPEED = 0.5;
    private static final double HOOD_LOWER_SPEED = -0.5;
    // *************************************************************

    // --------- Flywheel variables ------  
    public enum FlywheelState {ON, OFF};
    private FlywheelState flywheelState = FlywheelState.OFF;
    private enum FlywheelStartupState {ON, OFF};
    private FlywheelStartupState flywheelStartupState = FlywheelStartupState.ON;

    public enum FlywheelSpeedState {UP_TO_SPEED, NOT_UP_TO_SPEED}
    public FlywheelSpeedState flywheelSpeedState = FlywheelSpeedState.NOT_UP_TO_SPEED;

    public enum FlywheelGoalTarget { HIGH, LOW};
    public FlywheelGoalTarget goalTarget = FlywheelGoalTarget.HIGH;

    private double currentRPM = 0;
    private double targetRPM = 0;

    private double pidSetpointRPM = 0;        // this needs to be 1/2 the targetRPM
    private double timeCount = 0;

    // Start-up from stop PID parameters
    private double sP = 0.0002;
    private  double sI = 0.0000003;
    private double sD = 0.0;
    private double sIz = 0.0;
    private double sFF = 0.0;

    // Cruise PID parameters
    private double kP = 0.001;
    private double kI = 0.00000001;
    private double kD = 0.02;
    private double kIz = 0.0;
    private double kFF = 0.0;
    private double maxOutput = 1.0;
    private double minOutput = -1.0;

    private double handoffPower = 0;
    private double turretHoodPower = 0;
    private double turretRotatePower = 0;

    private double flywheelSetPoint = 0;

    private static final double HoodConversion = 0.3;   //Need tuning!
    private static final double TurretConversion = 0.3; //Need tuning!

    private static final double HandoffEjectionPower = 0.7; //Need tuning!

    private static final int FLYWHEEL_RIGHT_CAN_ID = 16;
    private static final int FLYWHEEL_LEFT_CAN_ID = 15;

    // ----- Flywheel --------
    private CANSparkMax     flywheelMotor, flywheelMotor2;
    private CANPIDController flyWheelMotor_pidController;
    private CANEncoder      flywheelEncoder;

    private enum MaxSparkStatus {ONLINE, OFFLINE};
    private MaxSparkStatus maxSparkStatus = MaxSparkStatus.OFFLINE;

    // ---------------------------
    public static enum TurretSwitchPressed{LEFT, RIGHT, NEITHER};
    public static enum HoodSwitchPressed{EXTENDED, RETRACTED, NEITHER};
    private static final boolean LEFT_LIMIT_SWITCH_TRUE = false;
    private static final boolean RIGHT_LIMIT_SWITCH_TRUE = false;


    private static enum SparkMaxStatus {ONLINE, OFFLINE};
    private SparkMaxStatus sparkMaxStatus = SparkMaxStatus.OFFLINE;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private DigitalInput turretRightLimitSwitch;
private DigitalInput turretLeftLimitSwitch;
private PWMVictorSPX turretRotateMotor;
private AnalogPotentiometer turretHoodPot;
private WPI_VictorSPX handoffMotor;
private WPI_TalonSRX turretHoodMotor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
   

    public shooterSubSys() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
turretRightLimitSwitch = new DigitalInput(8);
addChild("turretRightLimitSwitch",turretRightLimitSwitch);

        
turretLeftLimitSwitch = new DigitalInput(7);
addChild("turretLeftLimitSwitch",turretLeftLimitSwitch);

        
turretRotateMotor = new PWMVictorSPX(9);
addChild("turretRotateMotor",turretRotateMotor);
turretRotateMotor.setInverted(false);
        
turretHoodPot = new AnalogPotentiometer(1, 5.0, 0.0);
addChild("turretHoodPot",turretHoodPot);

        
handoffMotor = new WPI_VictorSPX(5);


        
turretHoodMotor = new WPI_TalonSRX(4);


        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

    
    // Instantiate the SparkMax Speed Controllers
    instantiateSparkMaxControllers();


    post_Startup_PID_Data();              // setup for startup PID
    
    }



    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        SmartDashboard.putNumber("Flywheel RPM", getFlywheelRPM());
        processFlywheelState();
        updateSmartDashboard();

    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // **********************************************************************************
    //                                   Main Methods
    // **********************************************************************************


    // -----------------------------------------------------------------------------------
    //                                 Flywheel Methods                                 //
    // -----------------------------------------------------------------------------------
    
    public void flywheelSetOn(double rpm, boolean goal){
        // turn on pid flywheel goal=true for HIGH GOAL, false for LOW GOAL

        if (( flywheelState == FlywheelState.ON ) && 
            ((( goal == true) && (goalTarget == FlywheelGoalTarget.HIGH)) || (( goal == false) && (goalTarget == FlywheelGoalTarget.LOW))) && 
            ( flywheelSpeedState == FlywheelSpeedState.UP_TO_SPEED )) {
                // we are going to same target and we are already up to speed so were done
                return;
            }

        if (goal == true) {
            goalTarget = FlywheelGoalTarget.HIGH;
        } else {
            goalTarget = FlywheelGoalTarget.LOW;
        }

        flywheelStartupState = FlywheelStartupState.ON;
        //flyWheelMotor_pidController.setIAccum(0);
        post_Startup_PID_Data();   // Post startup PID data to controllers
        targetRPM = rpm;
        flyWheelMotor_pidController.setReference(targetRPM/2, ControlType.kVelocity);    
        flywheelState = FlywheelState.ON;


        flywheelSpeedState = FlywheelSpeedState.NOT_UP_TO_SPEED;    // 
    }

    public void flywheelSetOff(){
        flywheelStartupState = FlywheelStartupState.OFF;
        flyWheelMotor_pidController.setReference(0, ControlType.kDutyCycle);
        flywheelState = FlywheelState.OFF;
        flywheelSpeedState = FlywheelSpeedState.NOT_UP_TO_SPEED;
    }

    public FlywheelState getFlywheelState(){
        return flywheelState;    
    }
    
    public FlywheelGoalTarget getFlywheelTarget(){
        return goalTarget;
    }

    public FlywheelSpeedState getFlywheelSpeedState(){
        return flywheelSpeedState;
    }

    public double getFlywheelRPM() {
        double rpm = 0;
        if (maxSparkStatus == MaxSparkStatus.ONLINE) {
            rpm = 2 * flywheelEncoder.getVelocity();
            //System.out.println("---- SparkMax Velocity = " + rpm + " --------");
        }
        return rpm;
    }
    
    private void processFlywheelState(){
        if (flywheelState == FlywheelState.ON){
            currentRPM = getFlywheelRPM(); 
            if (flywheelStartupState == FlywheelStartupState.ON){
                if (currentRPM >= targetRPM - 200){
                    // Were up to speed .. changing to Cruise PID data from shuffleboard
                    flywheelSpeedState = FlywheelSpeedState.UP_TO_SPEED;
                    post_Cruise_PID_Data();  
                    flywheelStartupState = FlywheelStartupState.OFF;
                }
            }
            // continue to update setpoint
            flyWheelMotor_pidController.setReference(targetRPM/2, ControlType.kVelocity); 
        }

        if (flywheelState == FlywheelState.OFF){
            // Flywheel state is OFF so stop the flywheel
            flyWheelMotor_pidController.setReference(0, ControlType.kDutyCycle);
        }
    }

    // -----------------------------------------------------------------------------------
    //                                 Handoff Methods                                  //
    // -----------------------------------------------------------------------------------

    public void handoffMotorStop() {
        handoffMotor.set(0);
        handoffPower = 0;
        //flyWheelMotor_pidController.setSmartMotionAllowedClosedLoopError(allowedErr, slotID);
        
    }

    public void handoffMotorSet( double speed) {
        handoffPower = speed;
        handoffMotor.set(-HandoffEjectionPower);
    }


    // -------------------------------------------------------------------------------------
    //                                Turret Rotate Methods                               //
    // -------------------------------------------------------------------------------------
    
    public void turretRotateMotorStop() {
        turretRotateMotor.set(0);
        turretRotatePower = 0; 
    }

    public void turretRotateMotorSet(double power, boolean overide) {
        if (overide == true) {
            // were invoking manual overide of limit switch checks DANGEROUS !!!
            turretRotateMotor.set(-power);          // inverted do to wiring issue
            turretRotatePower = power; 
            return;           
        }
        //System.out.println("Rotating the Turret Pwr=" + power);
        if (power <= 0) {
            // were turning left
            if (isLeftLimitSwitchPressed() != true) {
                // were OK to turn Left
                //System.out.println("Rotating Left pwr = " + power);
                turretRotateMotor.set(-power);      // inverted do to wiring issue
                turretRotatePower = power;
                return;
            }
        } else {
            // were turning right
            if (isRightLimitSwitchPressed() != true) {
                // were OK to turn Right
                //System.out.println("Rotating Right pwr = " + power);
                turretRotateMotor.set(-power);      // inverted do to wiring issue
                turretRotatePower = power;
                return;
            }
        }
        // we got here because a limit switch has been pressed
        turretRotateMotorStop();

    }

    public boolean isLeftLimitSwitchPressed(){
        if (turretLeftLimitSwitch.get() == LEFT_LIMIT_SWITCH_TRUE) {
            return true;
        } else {
            return false;
        }
    }

    public boolean isRightLimitSwitchPressed(){
        if (turretRightLimitSwitch.get() == RIGHT_LIMIT_SWITCH_TRUE) {
            return true;
        } else {
            return false;
        }
    }

    public TurretSwitchPressed checkTurretRotateLimitSwitches() {
        // If variable isn't updated we know neither limit switch is pressed.
        TurretSwitchPressed whichLimitSwitchPressed = TurretSwitchPressed.NEITHER; 
   
        if (turretLeftLimitSwitch.get() == true) {
            whichLimitSwitchPressed = TurretSwitchPressed.LEFT;
        } else if (turretRightLimitSwitch.get() == true) {
            whichLimitSwitchPressed = TurretSwitchPressed.RIGHT;
        }
        return whichLimitSwitchPressed;
    }

    // -----------------------------------------------------------------------------------
    //                                 Hood Methods                                     //
    // -----------------------------------------------------------------------------------
    //                  Turret Data
    // fully Extended raises ball for a closer target
    // 112 inches distance to goal - Pot 4.99  for a ctr shot    ie) fully extended for CLOS Goal
    // 
    // fully Retracted lowers ball for a farther target
    // 380 inches distance to goal - Pot 0.0049 for a ctr shot   ie) fully retracted for Further Goal
    //

    public void turretHoodMotorStop() {
        turretHoodPower = 0.0;
        turretHoodMotor.set(turretHoodPower);
    }

    public void raiseHood(){
        // RAISE ball eject higher  ie) RETRACT hood to shoot Higher for CLOSE target
        if (isHoodFullyRetracted()) {
            // were at limit stop motor
            turretHoodPower = 0;    
        } else {
            // OK to move
            turretHoodPower = HOOD_RAISE_SPEED;
        }
        turretHoodMotor.set(turretHoodPower);
    }

    public void lowerHood(){
        // LOWER ball eject lower  ie) EXTEND hood to shoot Lower for FAR target
        if (isHoodFullyExtended()) {
            // were at limit stop motor
            turretHoodPower = 0;    
        } else {
            // OK to move
            turretHoodPower = HOOD_LOWER_SPEED;
        }
        turretHoodMotor.set(turretHoodPower);
    }

    public boolean isHoodFullyRetracted(){
        // RETRACT hood to shoot Higher for CLOSE target
        if (getHoodPot() <= HOOD_RETRACTED_MIN ) {
            return true;
        } else {
            return false;
        }
    }

    public boolean isHoodFullyExtended(){
        // RETRACT hood to shoot Higher for CLOSE target
        if (getHoodPot() >= HOOD_EXTENDED_MAX ) {
            // were at the far limit do not move any more
            return true;
        } else {
            return false;
        }
    }

    public double getHoodPot() {
        return turretHoodPot.get();
    }

    public void turretHoodMotorSet(double power, boolean overide) {
        if (overide == true) {
            // were invoking manual overide of limit checks DANGEROUS !!!
            turretHoodMotor.set(-power);
            turretHoodPower = power; 
            return;
        }

        if (power > 0) {
            // were raising the hood
            if (getHoodPot() >= HOOD_EXTENDED_MAX ) {
                // were at the far limit do not move any more
                turretHoodMotorStop();
                turretHoodPower = 0;
            } else {
                // were OK to move
                turretHoodPower = power;
                turretHoodMotor.set(-power);
            }
        } else {
            // were raising the hood
            if (getHoodPot() <= HOOD_RETRACTED_MIN ) {
                // were at the far limit do not move any more
                turretHoodMotorStop();
                turretHoodPower = 0;
            } else {
                // were OK to move
                turretHoodPower = power;
                turretHoodMotor.set(-power);
            }
        }
    }

    public double getHoodSlope(double deadband) {
        return (HOOD_RETRACTED_MIN - HOOD_EXTENDED_MAX) / (1 - deadband); // Solving for slope using two points (y2-y1)/(x2-x1)
    }

    public double getHoodIntercept(double slope) {
        return (HOOD_RETRACTED_MIN - 1 * slope); // Solving for b on y=mx+b
    }

    public double linearizeHoodPower(double joystickValue, double deadband) {
        double slope = getHoodSlope(deadband);
        double intercept = getHoodIntercept(slope);

        return joystickValue * slope + intercept; // y is being returned from y=mx+b
    }

    // -----------------------------------------------------------------------------------------------
    //                                  Flywheel PID Methods                                        //
    // -----------------------------------------------------------------------------------------------
    
    private void instantiateSparkMaxControllers(){
        // Instantiate the SparkMax Speed Controllers
        flywheelMotor =  new CANSparkMax(15, MotorType.kBrushless); // Right
        flywheelMotor2 = new CANSparkMax(16, MotorType.kBrushless); // Left

        flywheelMotor.restoreFactoryDefaults();
        flywheelMotor2.restoreFactoryDefaults();
        
        flywheelMotor2.follow(flywheelMotor, true);  // Follow (true = invert follower polarity)      
        flywheelEncoder = flywheelMotor.getEncoder();
        flyWheelMotor_pidController = flywheelMotor.getPIDController();

        if ( flywheelMotor.getFirmwareVersion() == 0) {
            maxSparkStatus = MaxSparkStatus.OFFLINE;
            System.out.println("** SPARK MAX flywheelMotor CONTROLLER NOT FOUND !! **");      
        } else {
            System.out.println("** SPARK MAX flywheelMotor CONTROLLER Good !! **");      
            maxSparkStatus = MaxSparkStatus.ONLINE;
        }
    }


    public void post_Cruise_PID_Data(){
        // read PID coefficients from SmartDashboard
        // double p = SmartDashboard.getNumber("P Gain", 0);
        // double i = SmartDashboard.getNumber("I Gain", 0);
        // double d = SmartDashboard.getNumber("D Gain", 0);
        // double iz = SmartDashboard.getNumber("I Zone", 0);
        // double ff = SmartDashboard.getNumber("Feed Forward", 0);
        // double max = SmartDashboard.getNumber("Max Output", 0);
        // double min = SmartDashboard.getNumber("Min Output", 0);
        // pidFireDelta = SmartDashboard.getNumber("Fire Delta RPM", pidFireDelta);
        flyWheelMotor_pidController.setP(kP);
        flyWheelMotor_pidController.setI(kI);
        flyWheelMotor_pidController.setD(kD);
        flyWheelMotor_pidController.setIZone(kIz);
        flyWheelMotor_pidController.setFF(kFF);
        flyWheelMotor_pidController.setOutputRange(minOutput, maxOutput);
        //flyWheelMotor_pidController.setIAccum(0); 
    }

    public void post_Startup_PID_Data(){
        // read PID coefficients from SmartDashboard
        // double p = SmartDashboard.getNumber("Start P Gain", 0);
        // double i = SmartDashboard.getNumber("Start I Gain", 0);
        // double d = SmartDashboard.getNumber("Start D Gain", 0);
        // double iz = SmartDashboard.getNumber("Start I Zone", 0);
        // double ff = SmartDashboard.getNumber("Start Feed Forward", 0);
        // pidFireDelta = SmartDashboard.getNumber("Fire Delta RPM", pidFireDelta);
        flyWheelMotor_pidController.setP(sP);
        flyWheelMotor_pidController.setI(sI);
        flyWheelMotor_pidController.setD(sD);
        flyWheelMotor_pidController.setIZone(sIz);
        flyWheelMotor_pidController.setFF(sFF);
    }

    
    // -----------------------------------------------------------------------------------
    //                                 Misc Methods                                     //
    // -----------------------------------------------------------------------------------

    private void updateSmartDashboard(){
        if ( (displayCnt % 10) != 0) {
            // only update dashboard every 200 ms    
            displayCnt++;
            return;
        }
         displayCnt = 0;

         if (isLeftLimitSwitchPressed()) {
            SmartDashboard.putString("Turret Rotate Left Switch", "Pressed");
        } else {
            SmartDashboard.putString("Turret Rotate Left Switch", "Not Pressed");
        }
        if (isRightLimitSwitchPressed()) {
            SmartDashboard.putString("Turret Rotate Right Switch", "Pressed");
        } else {
            SmartDashboard.putString("Turret Rotate Right Switch", "Not Pressed");
        }

        SmartDashboard.putNumber("Hood Pot", getHoodPot());

        SmartDashboard.putNumber("Flywheel Set Point", flywheelSetPoint);
        SmartDashboard.putNumber("Turret Rotate Power", turretRotatePower);
        SmartDashboard.putNumber("Turret Hood Power", turretHoodPower);
        SmartDashboard.putNumber("Handoff Power", handoffPower);
        //SmartDashboard.putNumber("Flywheel RPM", getFlywheelRPM());
        SmartDashboard.putNumber("Flywheel Target RPM", targetRPM);

        // read PID coefficients from SmartDashboard       
        // SmartDashboard.putNumber("Start P Gain", sP);
        // SmartDashboard.putNumber("Start I Gain", sI);
        // SmartDashboard.putNumber("Start D Gain", sD);
        // SmartDashboard.putNumber("Start I Zone", sIz);
        // SmartDashboard.putNumber("Start Feed Forward", sFF);

        // SmartDashboard.putNumber("Cruise P Gain", kP);
        // SmartDashboard.putNumber("Cruise I Gain", kI);
        // SmartDashboard.putNumber("Cruise D Gain", kD);
        // SmartDashboard.putNumber("Cruise I Zone", kIz);
        // SmartDashboard.putNumber("Cruise Feed Forward", kFF);

        // SmartDashboard.putNumber("Max Output", maxOutput);
        // SmartDashboard.putNumber("Min Output", minOutput);

        if ( flywheelStartupState == FlywheelStartupState.ON) {
            SmartDashboard.putString("PID Mode", "Start-Up");
        }else {
            SmartDashboard.putString("PID Mode", "Cruise");
        }

    }


}
