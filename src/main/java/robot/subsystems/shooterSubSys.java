// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package robot.subsystems;

import robot.commands.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import com.revrobotics.CANEncoder;
import com.revrobotics.CANPIDController;
import com.revrobotics.CANSparkMax;
import com.revrobotics.ControlType;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import edu.wpi.first.wpilibj.Counter;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.DigitalSource;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;
import edu.wpi.first.wpilibj.AnalogPotentiometer;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.PWMVictorSPX;
import edu.wpi.first.wpilibj.SpeedController;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
    
public class shooterSubSys extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    String line;

    public double HIGH_GOAL_SPEED = 8000; //9050.0;
    public double HIGH_GOAL_MIN_SPEED = 7500;  // Thos is the minimum speed need to start firing
    public double LOW_GOAL_SPEED = 5000.0;
    public final double PID_FIRE_DELTA = 100.0;     // The range +- OK to Fire

    public final boolean LOW_GOAL = false;
    public final boolean HIGH_GOAL = true;
    
    private double displayCnt = 3;

    // Comment test
    // --------- Lidar variables ------  
    private DigitalInput lidarSensor;
    private Counter lidarCounter;
    private static final int LIDAR_CALIBRATION_OFFSET = -14;
    private int lidarPrintedWarningCount = 5;
    private double lidarDistance = 0;

    // *************************************************************
    //                  Turret Data
    // fully Extended raises ball for a closer target
    // 112 inches distance to goal - Pot 4.99  for a ctr shot    ie) fully extended for CLOS Goal
    // 
    // fully Retracted lowers ball for a farther target
    // 380 inches distance to goal - Pot 0.0049 for a ctr shot   ie) fully retracted for Further Goal
    //
    public static final double HOOD_EXTENDED_MIN = 0.005; //4.8;    // measured 4.85 
    public static final double HOOD_RETRACTED_MAX = 4.8;  //0.005;    // measured 0.005
    private static final double HOOD_RANGE = HOOD_RETRACTED_MAX - HOOD_EXTENDED_MIN;
    private static final double HOOD_RAISE_SPEED = -0.5;
    private static final double HOOD_LOWER_SPEED = +0.5;
    // *************************************************************

    public static enum ShooterSmardashState {UPDATE, NOUPDATE};
    public static ShooterSmardashState shooterSmardashState = ShooterSmardashState.NOUPDATE;

    // --------- Flywheel variables ------  
    public enum FlywheelState {ON, OFF};
    private FlywheelState flywheelState = FlywheelState.OFF;
    private enum FlywheelStartupState {ON, OFF};
    private FlywheelStartupState flywheelStartupState = FlywheelStartupState.ON;

    public enum FlywheelSpeedState {UP_TO_SPEED, NOT_UP_TO_SPEED}
    public FlywheelSpeedState flywheelSpeedState = FlywheelSpeedState.NOT_UP_TO_SPEED;

    public enum FlywheelGoalTarget { HIGH, LOW};
    public FlywheelGoalTarget goalTarget = FlywheelGoalTarget.HIGH;

    private double currentRPM = 0;
    private double targetRPM = 0;

    private double pidSetpointRPM = 0;        // this needs to be 1/2 the targetRPM
    private double timeCount = 0;

    private double avgRPM = 0;
    private double avgRPMMinus1 = 0;
    private double avgRPMMinus2 = 0;
    private double avgRPMMinus3 = 0;
    private double avgRPMMinus4 = 0;

    // Start-up from stop PID parameters
    private double sP = 0.0002;
    private double sI = 0.0000003;
    private double sD = 0.0;
    private double sIz = 0.0;
    private double sFF = 0.0;

    // Cruise PID parameters
    private double kP = 0.001;
    private double kI = 0.00000000001;
    private double kD = 0.02;
    private double kIz = 0.0;
    private double kFF = 0.0;
    private double maxOutput = 1.0;
    private double minOutput = -1.0;

    private double handoffPower = 0;
    private double turretHoodPower = 0;
    private double turretRotatePower = 0;

    private double flywheelSetPoint = 0;

    private static final double HoodConversion = 0.3;   //Need tuning!
    private static final double TurretConversion = 0.3; //Need tuning!

    private static final double HandoffEjectionPower = 0.7; //Need tuning!

    private static final int FLYWHEEL_RIGHT_CAN_ID = 16;
    private static final int FLYWHEEL_LEFT_CAN_ID = 15;

    // ----- Flywheel --------
    private CANSparkMax     flywheelMotor, flywheelMotor2;
    private CANPIDController flyWheelMotor_pidController;
    private CANEncoder      flywheelEncoder;

    private enum MaxSparkStatus {ONLINE, OFFLINE};
    private MaxSparkStatus maxSparkStatus = MaxSparkStatus.OFFLINE;

    // ---------------------------
    public static enum TurretSwitchPressed{LEFT, RIGHT, NEITHER};
    public static enum HoodSwitchPressed{EXTENDED, RETRACTED, NEITHER};
    private static final boolean LEFT_LIMIT_SWITCH_TRUE = false;
    private static final boolean RIGHT_LIMIT_SWITCH_TRUE = false;


    private static enum SparkMaxStatus {ONLINE, OFFLINE};
    private SparkMaxStatus sparkMaxStatus = SparkMaxStatus.OFFLINE;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private DigitalInput turretRightLimitSwitch;
private DigitalInput turretLeftLimitSwitch;
private PWMVictorSPX turretRotateMotor;
private AnalogPotentiometer turretHoodPot;
private WPI_VictorSPX handoffMotor;
private WPI_TalonSRX turretHoodMotor;
private Encoder rotateEncoder;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
   

    public shooterSubSys() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
turretRightLimitSwitch = new DigitalInput(8);
addChild("turretRightLimitSwitch",turretRightLimitSwitch);

        
turretLeftLimitSwitch = new DigitalInput(7);
addChild("turretLeftLimitSwitch",turretLeftLimitSwitch);

        
turretRotateMotor = new PWMVictorSPX(9);
addChild("turretRotateMotor",turretRotateMotor);
turretRotateMotor.setInverted(false);
        
turretHoodPot = new AnalogPotentiometer(1, 5.0, 0.0);
addChild("turretHoodPot",turretHoodPot);

        
handoffMotor = new WPI_VictorSPX(5);


        
turretHoodMotor = new WPI_TalonSRX(4);


        
rotateEncoder = new Encoder(4, 5, false, EncodingType.k4X);
addChild("rotateEncoder",rotateEncoder);
rotateEncoder.setDistancePerPulse(1.0);
rotateEncoder.setPIDSourceType(PIDSourceType.kRate);
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

    // Instantiate the SparkMax Speed Controllers
    instantiateSparkMaxControllers();
    rotateEncoder.reset();

    SmartDashboard.putNumber("Flywheel Set Point", flywheelSetPoint);
    SmartDashboard.putNumber("Turret Rotate Power", turretRotatePower);
    SmartDashboard.putNumber("Turret Hood Power", turretHoodPower);
    SmartDashboard.putNumber("Handoff Power", handoffPower);
    SmartDashboard.putNumber("Flywheel RPM", getFlywheelRPM());
    SmartDashboard.putNumber("Flywheel Target RPM", targetRPM);

    // read PID coefficients from SmartDashboard       
    SmartDashboard.putNumber("Start P Gain", sP);
    SmartDashboard.putNumber("Start I Gain", sI);
    SmartDashboard.putNumber("Start D Gain", sD);
    SmartDashboard.putNumber("Start I Zone", sIz);
    SmartDashboard.putNumber("Start Feed Forward", sFF);

    SmartDashboard.putNumber("Cruise P Gain", kP);
    SmartDashboard.putNumber("Cruise I Gain", kI);
    SmartDashboard.putNumber("Cruise D Gain", kD);
    SmartDashboard.putNumber("Cruise I Zone", kIz);
    SmartDashboard.putNumber("Cruise Feed Forward", kFF);

    post_Startup_PID_Data();              // setup for startup PID

    // Instantiate the Lidar Sensor
    lidarCounter = new Counter(9);
    lidarCounter.setMaxPeriod(1.0);
    lidarCounter.setSemiPeriodMode(true);
    
    }



    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        HIGH_GOAL_SPEED =  SmartDashboard.getNumber("Flywheel Set Point", flywheelSetPoint); // TODO Remove test only
        LOW_GOAL_SPEED = HIGH_GOAL_SPEED;                                                   // TODO Remove test only
        SmartDashboard.putNumber("Flywheel RPM", getFlywheelRPM());
        processFlywheelState();

        // Update running average flywheel RPM data
        avgRPM = (currentRPM + avgRPMMinus1 + avgRPMMinus2 + avgRPMMinus3) / 4;
        avgRPMMinus3 = avgRPMMinus2;
        avgRPMMinus2 = avgRPMMinus1;
        avgRPMMinus1 = avgRPM;
        SmartDashboard.putNumber("Average RPM", avgRPM);
   
        // update Lidar data
        updateLidarDistance();
        SmartDashboard.putNumber("Lidar Distance", lidarDistance);

        if ( shooterSmardashState==ShooterSmardashState.UPDATE) updateSmartDashboard();
    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // **********************************************************************************
    //                                   Main Methods
    // **********************************************************************************

    public void setSmartdashUpdatesOn(){
        shooterSmardashState = ShooterSmardashState.UPDATE;
    }
    public void setSmartdashUpdatesOf(){
        shooterSmardashState = ShooterSmardashState.NOUPDATE;
    }

    // -----------------------------------------------------------------------------------
    //                                    Lidar Methods                                 //
    // -----------------------------------------------------------------------------------

    public double getLidarDistance() {
        return lidarDistance;
    }

     private void updateLidarDistance(){
        double cm = 0;
        lidarDistance = 0;

        // if (isValidVisionTarget() == false) {
        //     // we Dont have a valid target in sight so set distance to zero
        //     // maybe we need to check for xAngle less than some thing like +- 5 degrees
        //     // for a vaild lidar measurement 
        //     return;
        // }

        if (lidarCounter.get() < 1) {
            if (lidarPrintedWarningCount-- >0){
                System.out.println("LidarLitePWM: waiting for distance measurment");
            }
            return; // no valid lidar response
        }
        cm = (lidarCounter.getPeriod() * 1000000.0 / 10.0) + LIDAR_CALIBRATION_OFFSET;
        lidarDistance = cm * 0.393701;   // this returns inches from cm
    }

    // -----------------------------------------------------------------------------------
    //                                 Flywheel Methods                                 //
    // -----------------------------------------------------------------------------------
    
    public void flywheelSetOn(double rpm, boolean goal){
        // turn on pid flywheel goal=true for HIGH GOAL, false for LOW GOAL

        if (( flywheelState == FlywheelState.ON ) && 
            ((( goal == true) && (goalTarget == FlywheelGoalTarget.HIGH)) || (( goal == false) && (goalTarget == FlywheelGoalTarget.LOW))) && 
            ( flywheelSpeedState == FlywheelSpeedState.UP_TO_SPEED )) {
                // we are going to same target and we are already up to speed so were done
                return;
            }

        if (goal == true) {
            goalTarget = FlywheelGoalTarget.HIGH;
        } else {
            goalTarget = FlywheelGoalTarget.LOW;
        }

        flywheelStartupState = FlywheelStartupState.ON;
        //flyWheelMotor_pidController.setIAccum(0);
        post_Startup_PID_Data();   // Post startup PID data to controllers
        targetRPM = rpm;
        flyWheelMotor_pidController.setReference(targetRPM/2, ControlType.kVelocity);    
        flywheelState = FlywheelState.ON;


        flywheelSpeedState = FlywheelSpeedState.NOT_UP_TO_SPEED;    // 
    }

    public void flywheelSetOff(){
        flywheelStartupState = FlywheelStartupState.OFF;
        flyWheelMotor_pidController.setReference(0, ControlType.kDutyCycle);
        flywheelState = FlywheelState.OFF;
        flywheelSpeedState = FlywheelSpeedState.NOT_UP_TO_SPEED;
    }

    public FlywheelState getFlywheelState(){
        return flywheelState;    
    }
    
    public FlywheelGoalTarget getFlywheelTarget(){
        return goalTarget;
    }

    public FlywheelSpeedState getFlywheelSpeedState(){
        return flywheelSpeedState;
    }

    public double getFlywheelRPM() {
        double rpm = 0;
        if (maxSparkStatus == MaxSparkStatus.ONLINE) {
            rpm = 2 * flywheelEncoder.getVelocity();
            //System.out.println("---- SparkMax Velocity = " + rpm + " --------");
        }
        return rpm;
    }
    
    private void processFlywheelState(){
        if (flywheelState == FlywheelState.ON){
            currentRPM = getFlywheelRPM(); 
            if (flywheelStartupState == FlywheelStartupState.ON){
                if (currentRPM >= targetRPM - 200){
                    // Were up to speed .. changing to Cruise PID data from shuffleboard
                    // 
                    // ******* Consider a way to adjust setpoint by difference between target and avg rpm
                    //
                    //
                    flywheelSpeedState = FlywheelSpeedState.UP_TO_SPEED;
                    post_Cruise_PID_Data();  
                    flywheelStartupState = FlywheelStartupState.OFF;
                }
            }
            // continue to update setpoint
            targetRPM = SmartDashboard.getNumber("Flywheel Set Point", flywheelSetPoint);
            flyWheelMotor_pidController.setReference(targetRPM/2, ControlType.kVelocity); 
        }

        if (flywheelState == FlywheelState.OFF){
            // Flywheel state is OFF so stop the flywheel
            flyWheelMotor_pidController.setReference(0, ControlType.kDutyCycle);
        }
    }

    // -----------------------------------------------------------------------------------
    //                                 Handoff Methods                                  //
    // -----------------------------------------------------------------------------------

    public void handoffMotorStop() {
        handoffMotor.set(0);
        handoffPower = 0;
        //flyWheelMotor_pidController.setSmartMotionAllowedClosedLoopError(allowedErr, slotID);
        
    }

    public void handoffMotorSet( double speed) {
        handoffPower = speed;
        handoffMotor.set(-HandoffEjectionPower);
    }


    // -------------------------------------------------------------------------------------
    //                                Turret Rotate Methods                               //
    // -------------------------------------------------------------------------------------

    public void resetHoodEncoder(){
        rotateEncoder.reset();
    }
    
    public double getRotateEncoderValue(){
        return rotateEncoder.get();
    }

    public double getRotateAngle(){
        // 512 count per rotation  512/360 = 1.422222 counts per degree
        // 139 per 90
        return getRotateEncoderValue() / 1.54444 ;
    }
    
    public void turretRotateMotorStop() {
        turretRotateMotor.set(0);
        turretRotatePower = 0; 
    }

    public void turretRotateMotorSet(double power, boolean overide) {
        if (overide == true) {
            // were invoking manual overide of limit switch checks DANGEROUS !!!
            turretRotateMotor.set(-power);          // inverted do to wiring issue
            turretRotatePower = power; 
            return;           
        }
        //System.out.println("Rotating the Turret Pwr=" + power);
        if (power <= 0) {
            // were turning left
            if (isLeftLimitSwitchPressed() != true) {
                // were OK to turn Left
                //System.out.println("Rotating Left pwr = " + power);
                turretRotateMotor.set(-power);      // inverted do to wiring issue
                turretRotatePower = power;
                return;
            }
        } else {
            // were turning right
            if (isRightLimitSwitchPressed() != true) {
                // were OK to turn Right
                //System.out.println("Rotating Right pwr = " + power);
                turretRotateMotor.set(-power);      // inverted do to wiring issue
                turretRotatePower = power;
                return;
            }
        }
        // we got here because a limit switch has been pressed
        turretRotateMotorStop();

    }

    public boolean isLeftLimitSwitchPressed(){
        if (turretLeftLimitSwitch.get() == LEFT_LIMIT_SWITCH_TRUE) {
            return true;
        } else {
            return false;
        }
    }

    public boolean isRightLimitSwitchPressed(){
        if (turretRightLimitSwitch.get() == RIGHT_LIMIT_SWITCH_TRUE) {
            return true;
        } else {
            return false;
        }
    }

    public TurretSwitchPressed checkTurretRotateLimitSwitches() {
        // If variable isn't updated we know neither limit switch is pressed.
        TurretSwitchPressed whichLimitSwitchPressed = TurretSwitchPressed.NEITHER; 
   
        if (turretLeftLimitSwitch.get() == true) {
            whichLimitSwitchPressed = TurretSwitchPressed.LEFT;
        } else if (turretRightLimitSwitch.get() == true) {
            whichLimitSwitchPressed = TurretSwitchPressed.RIGHT;
        }
        return whichLimitSwitchPressed;
    }

    public double calcRotateMotorForPosition(double currentHoodAngle, double targetHoodAngle, double TARGET_X_DEADBAND){
        double delta = targetHoodAngle - currentHoodAngle;
        double turretRotateSpeed = 0;
        if ( delta > 0 ) {
            // we need to turn to the right
            //turretRotateState = TurretRotateState.ROTATING_RIGHT;
            if      (delta >= 20.0)               { turretRotateSpeed = 0.5; }
            else if (delta >= 10.0)               { turretRotateSpeed = 0.4; }
            else if (delta >= 5.0)                { turretRotateSpeed = 0.25; }
            else if (delta >= 2.5)                { turretRotateSpeed = 0.22; }
            else if (delta >= 1.5)                { turretRotateSpeed = 0.18; }
            else if (delta >= TARGET_X_DEADBAND)  { turretRotateSpeed = 0.15; }
            else                                  { turretRotateSpeed = 0.0;
                                                    //Robot.shooterSubSys.turretRotateMotorStop(); 
                                                    //turretRotateState = TurretRotateState.DONE;
                                                  }
        } else {
            // we need to turn to the left
            //turretRotateState = TurretRotateState.ROTATING_LEFT;
            if      (delta <= -20.0)              { turretRotateSpeed = -0.5; } 
            else if (delta <= -10.0)              { turretRotateSpeed = -0.4; }
            else if (delta <= -5.0)               { turretRotateSpeed = -0.25; }
            else if (delta <= -2.5)               { turretRotateSpeed = -0.22; }
            else if (delta <= -1.5)               { turretRotateSpeed = -0.20; }
            else if (delta <= -TARGET_X_DEADBAND) { turretRotateSpeed = -0.17; }
            else                                  { turretRotateSpeed =  0.0;
                                                    //Robot.shooterSubSys.turretRotateMotorStop(); 
                                                    //turretRotateState = TurretRotateState.DONE;
                                                  }
        }
        return turretRotateSpeed;
    }

    // -----------------------------------------------------------------------------------
    //                                 Hood Methods                                     //
    // -----------------------------------------------------------------------------------
    //                  Turret Data
    // fully Retracted raises ball for a closer target
    // 112 inches distance to goal - Pot 4.99  for a ctr shot    ie) fully Retracted for Close/High Goal
    // 
    // fully Extended lowers ball for a farther target
    // 380 inches distance to goal - Pot 0.005 for a ctr shot   ie) fully Extended for Furthest Goal
    //

    public void turretHoodMotorStop() {
        turretHoodPower = 0.0;
        turretHoodMotor.set(turretHoodPower);
    }

    public void raiseHood(){
        // RAISE ball eject higher  ie) RETRACT hood to shoot Higher for CLOSE target
        if (isHoodFullyRetracted()) {
            // were at limit stop motor
            turretHoodPower = 0;    
        } else {
            // OK to move
            turretHoodPower = HOOD_RAISE_SPEED;
        }
        turretHoodMotor.set(turretHoodPower);
    }

    public void lowerHood(){
        // LOWER ball eject lower  ie) EXTEND hood to shoot Lower for FAR target
        if (isHoodFullyExtended()) {
            // were at limit stop motor
            turretHoodPower = 0;    
        } else {
            // OK to move
            turretHoodPower = HOOD_LOWER_SPEED;
        }
        turretHoodMotor.set(turretHoodPower);
    }

    public boolean isHoodFullyRetracted(){
        // RETRACT hood to shoot Higher for CLOSE target
        if (getHoodPot() >= HOOD_RETRACTED_MAX ) {
            return true;
        } else {
            return false;
        }
    }

    public boolean isHoodFullyExtended(){
        // RETRACT hood to shoot Higher for CLOSE target
        if (getHoodPot() <= HOOD_EXTENDED_MIN ) {
            // were at the far limit do not move any more
            return true;
        } else {
            return false;
        }
    }

    public double getHoodPot() {
        return turretHoodPot.get();
    }

    public void turretHoodMotorSet(double power, boolean overide) {
        if (overide == true) {
            // were invoking manual overide of limit checks DANGEROUS !!!
            turretHoodMotor.set(power);
            turretHoodPower = power; 
            return;
        }

        if (power > 0) {
            // were Lowering/Extending the hood
            if (getHoodPot() <= HOOD_EXTENDED_MIN ) {
                // were at the far limit do not move any more
                turretHoodMotorStop();
                turretHoodPower = 0;
            } else {
                // were OK to move
                turretHoodPower = power;
                turretHoodMotor.set(power);
            }
        } else {
            // were Raising/Retracting the hood
            if (getHoodPot() >= HOOD_RETRACTED_MAX ) {
                // were at the far limit do not move any more
                turretHoodMotorStop();
                turretHoodPower = 0;
            } else {
                // were OK to move
                turretHoodPower = power;
                turretHoodMotor.set(power);
            }
        }
    }

    public double calcHoodMotorForPosition(double currHoodPos, double targetHoodPosition, double HOOD_DEADBAND){
        double delta = targetHoodPosition - currHoodPos;
        double moveSpeed = 0;

        if (Math.abs(delta) < HOOD_DEADBAND ) {
            // we have reached our target so time to end
            return moveSpeed;
        }

        if (currHoodPos < targetHoodPosition) {
            // Need to Raise Hood
            delta = targetHoodPosition - currHoodPos;
            if      (delta > 2)     moveSpeed = -0.5;
            else if (delta > 1)     moveSpeed = -0.45;
            else if (delta > 0.5)   moveSpeed = -0.35;
            else if (delta > 0.25)  moveSpeed = -0.25;
            else                    moveSpeed = -0.15;
        } else {
            // Need to Lower Hood
            delta = Math.abs(targetHoodPosition - currHoodPos);
            if      (delta > 2)     moveSpeed = 0.5;
            else if (delta > 1)     moveSpeed = 0.45;
            else if (delta > 0.5)   moveSpeed = 0.35;
            else if (delta > 0.25)  moveSpeed = 0.25;
            else                    moveSpeed = 0.15;
        }
        return moveSpeed;
    }

    // -----------------------------------------------------------------------------------------------
    //                                  Flywheel PID Methods                                        //
    // -----------------------------------------------------------------------------------------------
    
    private void instantiateSparkMaxControllers(){
        // Instantiate the SparkMax Speed Controllers
        flywheelMotor =  new CANSparkMax(15, MotorType.kBrushless); // Right
        flywheelMotor2 = new CANSparkMax(16, MotorType.kBrushless); // Left

        flywheelMotor.restoreFactoryDefaults();
        flywheelMotor2.restoreFactoryDefaults();
        
        flywheelMotor2.follow(flywheelMotor, true);  // Follow (true = invert follower polarity)      
        flywheelEncoder = flywheelMotor.getEncoder();
        flyWheelMotor_pidController = flywheelMotor.getPIDController();

        if ( flywheelMotor.getFirmwareVersion() == 0) {
            maxSparkStatus = MaxSparkStatus.OFFLINE;
            System.out.println("** SPARK MAX flywheelMotor CONTROLLER NOT FOUND !! **");      
        } else {
            System.out.println("** SPARK MAX flywheelMotor CONTROLLER Good !! **");      
            maxSparkStatus = MaxSparkStatus.ONLINE;
        }
    }


    public void post_Cruise_PID_Data(){
        // read PID coefficients from SmartDashboard
         double p = SmartDashboard.getNumber("P Gain", 0);
         double i = SmartDashboard.getNumber("I Gain", 0);
         double d = SmartDashboard.getNumber("D Gain", 0);
         double iz = SmartDashboard.getNumber("I Zone", 0);
         double ff = SmartDashboard.getNumber("Feed Forward", 0);
         double max = SmartDashboard.getNumber("Max Output", 0);
         double min = SmartDashboard.getNumber("Min Output", 0);
        // pidFireDelta = SmartDashboard.getNumber("Fire Delta RPM", pidFireDelta);
        flyWheelMotor_pidController.setP(kP);
        flyWheelMotor_pidController.setI(kI);
        flyWheelMotor_pidController.setD(kD);
        flyWheelMotor_pidController.setIZone(kIz);
        flyWheelMotor_pidController.setFF(kFF);
        flyWheelMotor_pidController.setOutputRange(minOutput, maxOutput);
        //flyWheelMotor_pidController.setIAccum(0); 
    }

    public void post_Startup_PID_Data(){
        // read PID coefficients from SmartDashboard
         double p = SmartDashboard.getNumber("Start P Gain", 0);
         double i = SmartDashboard.getNumber("Start I Gain", 0);
         double d = SmartDashboard.getNumber("Start D Gain", 0);
         double iz = SmartDashboard.getNumber("Start I Zone", 0);
         double ff = SmartDashboard.getNumber("Start Feed Forward", 0);
         //pidFireDelta = SmartDashboard.getNumber("Fire Delta RPM", pidFireDelta);
        flyWheelMotor_pidController.setP(sP);
        flyWheelMotor_pidController.setI(sI);
        flyWheelMotor_pidController.setD(sD);
        flyWheelMotor_pidController.setIZone(sIz);
        flyWheelMotor_pidController.setFF(sFF);
    }

    
    // -----------------------------------------------------------------------------------
    //                                 Misc Methods                                     //
    // -----------------------------------------------------------------------------------

    private void updateSmartDashboard(){
        if ( (displayCnt % 10) != 0) {
            // only update dashboard every 200 ms    
            displayCnt++;
            return;
        }
         displayCnt = 0;

         if (isLeftLimitSwitchPressed()) {
            SmartDashboard.putString("Turret Rotate Left Switch", "Pressed");
        } else {
            SmartDashboard.putString("Turret Rotate Left Switch", "Not Pressed");
        }
        if (isRightLimitSwitchPressed()) {
            SmartDashboard.putString("Turret Rotate Right Switch", "Pressed");
        } else {
            SmartDashboard.putString("Turret Rotate Right Switch", "Not Pressed");
        }

        SmartDashboard.putNumber("Hood Pot", getHoodPot());
        SmartDashboard.putNumber("Rotate Encoder Value", getRotateEncoderValue());
        SmartDashboard.putNumber("Rotate Encoder Angle", getRotateAngle());

        // SmartDashboard.putNumber("Flywheel Set Point", flywheelSetPoint);
        // SmartDashboard.putNumber("Turret Rotate Power", turretRotatePower);
        // SmartDashboard.putNumber("Turret Hood Power", turretHoodPower);
        // SmartDashboard.putNumber("Handoff Power", handoffPower);
        // SmartDashboard.putNumber("Flywheel RPM", getFlywheelRPM());
        // SmartDashboard.putNumber("Flywheel Target RPM", targetRPM);

        // // read PID coefficients from SmartDashboard       
        //  SmartDashboard.putNumber("Start P Gain", sP);
        //  SmartDashboard.putNumber("Start I Gain", sI);
        //  SmartDashboard.putNumber("Start D Gain", sD);
        //  SmartDashboard.putNumber("Start I Zone", sIz);
        //  SmartDashboard.putNumber("Start Feed Forward", sFF);

        //  SmartDashboard.putNumber("Cruise P Gain", kP);
        //  SmartDashboard.putNumber("Cruise I Gain", kI);
        //  SmartDashboard.putNumber("Cruise D Gain", kD);
        //  SmartDashboard.putNumber("Cruise I Zone", kIz);
        //  SmartDashboard.putNumber("Cruise Feed Forward", kFF);

        // SmartDashboard.putNumber("Max Output", maxOutput);
        // SmartDashboard.putNumber("Min Output", minOutput);

        if ( flywheelStartupState == FlywheelStartupState.ON) {
            SmartDashboard.putString("PID Mode", "Start-Up");
        }else {
            SmartDashboard.putString("PID Mode", "Cruise");
        }

        SmartDashboard.putNumber("Lidar Distance", lidarDistance);
        

    }


}
