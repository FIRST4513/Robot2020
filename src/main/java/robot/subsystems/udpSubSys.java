// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package robot.subsystems;

//import robot.commands.*;
//import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.command.Subsystem;
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketTimeoutException;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import robot.Robot;
import robot.utils.MyUdpClient;

//import robot.commands.udpStartServerCmd;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class udpSubSys extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    String line = "";
    public static enum UDPSmardashState {UPDATE, NOUPDATE};
    public static UDPSmardashState uDPSmardashState = UDPSmardashState.NOUPDATE;

     
    private int loopCtr = 0;
    private UdpServer mServer=null ;

    

    private String currMsg = "";
    private String lastMsg = "";

    private double displayCnt = 0;
    private int Xpos, Ypos;
    private double lastXpos, lastYpos;

    private double Xangle, Yangle, distance;
    private double slope, latency, time;
    
    private boolean validVisionTarget, lastValidVisionTarget;

    public udpSubSys() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    

    // ***** removed this line 2/22/2021 due to limelight not needing udp ******
    //startUdpServer(5801);       // Startup server automatically on startup
    // ******

}

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {

         //If UDP Server is running then check for incomming packets from the vision processor
        if (isRunning()) {
            checkForIncommingMessage();
        }


        if (uDPSmardashState == UDPSmardashState.UPDATE) updateSmartDashboard();

    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void setSmartdashUpdatesOn()     { uDPSmardashState = UDPSmardashState.UPDATE; }
    public void setSmartdashUpdatesOf()     { uDPSmardashState = UDPSmardashState.NOUPDATE; }

    // Get Vision Target data
    public boolean isValidVisionTarget()    { return validVisionTarget; }
    public double getVisionTargetX()        { return Xpos; }
    public double getVisionTargetY()        { return Ypos; }
    public double getXangle()               { return Xangle; }
    public double getYangle()               { return Yangle; }
    public double getVisionDistance()       { return distance; }
    public double getVisionSlope()          { return slope; }
    public double getVisionTime()           { return time; }
    public double getVisionLatency()        { return latency; }
     
    

    // Vision processing Methods
    private void checkForIncommingMessage(){
        // setup for default no target seen
        loopCtr = 2;

        // Clear data
        Xpos = Ypos = 0;
        Xangle = Yangle = 0;
        distance = 0;
        slope = latency = time = 0;
        validVisionTarget = false;

        //String testMsg1 = "TURRET target=T bearing-x=-15.84 bearing-y=46.01 base_range=75.29 slope
                        //=-0.83871 x-pos=419 y-pos=81 time=1582500753.4632208 latency=001372075080871582";
        //String testMsg2 = "TURRET target=F";

        //System.out.println("\n-- "+System.currentTimeMillis());
        //long start = System.currentTimeMillis();
        //System.out.println("+++ "+start);
        currMsg = getLastMessage(true);  //   true = (Clear buffer after getting msg) false = (do not clear buffer)

        //SmartDashboard.putString("Vision MSG Test", currMsg);
        if ((currMsg.isEmpty() || (currMsg.equals("No Msg")) || (currMsg.equals("(Not Running)")))) {
            return;
        }
        
        //System.out.println(currMsg);
        //System.out.println("Retrieve took "+(System.currentTimeMillis()-start));
        try {
             parseIncommingMsg(currMsg);
        } catch (Exception e) {
            System.out.println("Error in parsing UDP Msg");
        }
    }

    public void parseIncommingMsg(String msg){
        //System.out.println("Line 1");

        String validTgtLbl="target=T";
        String invalidTgtLbl="target=F";
        String xAngleLbl="bearing-x=";
        String yAngleLbl="bearing-y=";
        String distLbl="base_range=";
        String slopeLbl="slope=";
        String xPosLbl="x-pos=";
        String yPosLbl="y-pos=";
        String timeLbl="time=";
        String latencyLbl="latency=";

        if (msg.indexOf(validTgtLbl) < 0){
            // no valid target is seen
            //System.out.println("No vision tgarget in sight");
            return;
        }
    
        // We have a valid target in site so continue parsing coords
        validVisionTarget = true;
 
        int xAngleIdx = msg.indexOf(xAngleLbl);
        int yAngleIdx = msg.indexOf(yAngleLbl);
        int distanceIdx = msg.indexOf(distLbl);
        int slopeIdx= msg.indexOf(slopeLbl);
        int xPosIdx = msg.indexOf(xPosLbl);       // positive number = text found at this position 0,1,2,.....
        int yPosIdx = msg.indexOf(yPosLbl);       // negative number = string not found
        int timeIdx= msg.indexOf(timeLbl);
        int latencyIdx= msg.indexOf(latencyLbl);
        int msgLen = msg.length();

        String xAngleStr = msg.substring(xAngleIdx+(xAngleLbl.length()), yAngleIdx-1);
        String yAngleStr = msg.substring(yAngleIdx+(yAngleLbl.length()), distanceIdx-1);
        String distanceStr = msg.substring(distanceIdx+(distLbl.length()), slopeIdx-1);
        String slopeStr = msg.substring(slopeIdx+(slopeLbl.length()), xPosIdx-1);
        String xPosStr = msg.substring(xPosIdx+(xPosLbl.length()), yPosIdx-1);
        String yPosStr = msg.substring(yPosIdx+(yPosLbl.length()), timeIdx-1);
        String timeStr = msg.substring(timeIdx+(timeLbl.length()), latencyIdx-1);
        String latencyStr = msg.substring(latencyIdx+(latencyLbl.length()), msgLen);

        Xangle = stringToDouble(xAngleStr);
        Yangle = stringToDouble(yAngleStr);
        distance = stringToDouble(distanceStr);
        slope = stringToDouble(slopeStr);
        Xpos = (int) stringToDouble(xPosStr);
        Ypos = (int) stringToDouble(yPosStr);
        time = stringToDouble(timeStr);
        latency = stringToDouble(latencyStr);

    }
    
    private double stringToDouble(String str){
        double num;
        try {
            num = Double.parseDouble(str);
        } catch (Exception e) {
            validVisionTarget = false;  // maybe change this to a bad data error field
            num = 0;
        }
        return num;
    }
    
    // start the server thread on a given port
    public void startUdpServer(int port) {
        line = ("Starting Udp server on port " + port);
        System.out.println(line) ;
        Robot.logger.appendLog(line);

        try {
            mServer = new UdpServer(port);
            mServer.start();
        } catch(IOException e) {
            e.printStackTrace() ;
        }
    }
    
    public void stopUdpServer() {
    	if (mServer != null) {
            mServer.interrupt();
            line = ("Stopping Udp server !");
            System.out.println(line) ;
            Robot.logger.appendLog(line);   		
    	}
    	mServer = null ;        // allow garbage collection
    }
    
    public boolean isRunning() {
    	return (mServer != null) ;
    }
    
    public String getLastMessage(boolean clearIt) {
      String temp ;
    	if (mServer != null)
    	   temp = mServer.getDgramString(clearIt) ;
    	else
         temp = "(Not Running)" ;
      return temp ;
    }

    // ------------------- UDP Client Methods -----------
    private void sendClientMsg( String m_msg, String m_server, int m_port){
        MyUdpClient client = new MyUdpClient(m_server, m_port) ;            
        client.sendMessage(m_msg);
        client.close();
    }

    private void updateSmartDashboard(){
        if ( (displayCnt % 10) != 0) {
            // only update dashboard every 200 ms
            displayCnt++;
            return;
        }
        displayCnt = 0;
        
        if (isRunning()){
            SmartDashboard.putString("UDP Server Status 2", "Is Running");
            //SmartDashboard.putString("UDP Server Last Rcvd Msg", getLastMessage(false));
        } else {
            SmartDashboard.putString("UDP Server Status 2", "Is NOT Running");
            //SmartDashboard.putString("UDP Server Last Rcvd Msg", "");
        }
        if (validVisionTarget == true){
            SmartDashboard.putString("Vision Target", "Vision Target Acquired");
        } else {
            SmartDashboard.putString("Vision Target", "NO Vision Target Acquired");
        }
        SmartDashboard.putString("UDP Server Current Rcvd Msg", currMsg);
        SmartDashboard.putNumber("Vision Xpos", Xpos);
        SmartDashboard.putNumber("Vision Ypos", Ypos);
        SmartDashboard.putNumber("Vision X Angle", Xangle);
        SmartDashboard.putNumber("Vision Y Angle", Yangle);
        SmartDashboard.putNumber("Vision Distance", distance);
        SmartDashboard.putNumber("Vision Sloap", slope);
        SmartDashboard.putNumber("Vision Time", time);
        SmartDashboard.putNumber("Vision Latency", latency);
    }
}



// Server class is only visible to this file
// another thread can shut down this server by calling server.interrupt()
class UdpServer extends Thread 
{ 
    private DatagramSocket mSocket;
    // buffer for receiving socket data
    private byte[] mBuf = new byte[256] ;
    // string version of what was received
    private String mDgram = "(No Msg)" ;
 
	
	 // PHS NOTE: port>=1024 to avoid 
    // java.net.BindException: Permission denied
    public UdpServer(int port) throws IOException {
        // open a datagram socket on the indicated port
        // we accept connections from any client on that port
        mSocket = new DatagramSocket(port);
        // allow receive to block for only this amount of msec
        // this allws the trhead to periodically check for interrupted()
        // timeout will fire SocketTimeoutException below, but the socket will remain valid
        mSocket.setSoTimeout(1000);
    }
    
    // another thread can read the datagram by calling this
    // synchronization is not necessary because this thread only fills mBuf with DatagramSocket.receive()
    // which is atomic (or so we're told), as is the assignment to mDgram below
    public String getDgramString(boolean clearIt) {
      String temp ;
      if (clearIt) {
          // we need to do the read and the clear atomically, so don't 
          // let the server thread change it while we're doing that
          synchronized(this) {
              temp = mDgram ;
              mDgram = "" ;
          }
      }
      // but don't do a lock if we don't need to
      else 
          temp = mDgram ;                
      return temp ;
    } 
 
    // we extended thread, so all communication occurs in this run method    
    public void run() {
        while (!isInterrupted()) {
            // create a packet for up to our buffer length
            // if the message is longer than this, it will be truncated
            // if shorter, the packet length will shrink (thus we create a new one each time)
            DatagramPacket packet = new DatagramPacket(mBuf, mBuf.length);
            
            try {
                // Receive the packet. This will block or timeout and should be atomic.
                mSocket.receive(packet);

                // do not change this while an outside thread is doing
                // an atomic read-and-clear
                synchronized(this) {
                    mDgram = new String(packet.getData(), 0, packet.getLength());
                }
                
                // System.out.println("RCVD: " + mDgram) ;
                // we allow a client to shut us down as well
                if (mDgram.equals("*** STOP ***")) {
                    interrupt();   // yes, we can interrupt ourself, which will exit this loop
                    System.out.println("Udp server quitting") ;
                }
            } 
            catch (SocketTimeoutException to) {
                // for a timeout, just make a note and try again
                // having a timeout allows the thread to be interrupted
                // System.out.println("Udp server receive timed out") ;
            }
            catch (IOException e) {
                // for any other exception, maybe we should quit?
                e.printStackTrace() ;
            }
        }
        mSocket.close();
    }
}

