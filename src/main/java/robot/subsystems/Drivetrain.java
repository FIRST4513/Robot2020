// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package robot.subsystems;


import robot.Robot;
import robot.commands.*;
import robot.utils.Position;

//import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.command.Subsystem;
//import edu.wpi.first.wpilibj.PIDOutput;
//import edu.wpi.first.wpilibj.PIDSource;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import edu.wpi.first.wpilibj.Compressor;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
//import edu.wpi.first.wpilibj.Encoder;
//import edu.wpi.first.wpilibj.PowerDistributionPanel;
//import edu.wpi.first.wpilibj.SpeedController;
//import edu.wpi.first.wpilibj.SpeedControllerGroup;
//import edu.wpi.first.wpilibj.command.Subsystem;
//import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

//import com.ctre.phoenix.motorcontrol.ControlMode;
//import com.ctre.phoenix.motorcontrol.FeedbackDevice;
//import com.ctre.phoenix.motorcontrol.StatusFrameEnhanced;
//import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.kauailabs.navx.frc.AHRS;
import edu.wpi.first.wpilibj.SPI;
import robot.utils.*;

/**
 *
 */
public class Drivetrain extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private WPI_TalonSRX leftFMtr;
private WPI_TalonSRX leftRMtr;
private WPI_TalonSRX leftTMtr;
private SpeedControllerGroup leftMtrGrp;
private WPI_TalonSRX rightRMtr;
private WPI_TalonSRX rightFMtr;
private WPI_TalonSRX rightTMtr;
private SpeedControllerGroup rightMtrGrp;
private DifferentialDrive differentialDrive;
private Compressor compressor;
private Solenoid gearShiftValve;
private DigitalInput climbRetractSwitch;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    private AHRS mAHRS = new AHRS(SPI.Port.kMXP);

    public enum XBoxLRMode { LEFT, RIGHT };
    private XBoxLRMode xBoxLRMode = XBoxLRMode.RIGHT;	// this keeps track of our current drive mode

    // --------- PID Control Elements ----------------
    public enum DriveMode { INIT, TELE, AUTO_ROTATE, AUTO_STRAIGHT, AUTO_PATH, DONE, ATEND };
    private DriveMode mDriveMode = DriveMode.INIT;	// this keeps track of our current drive mode
    
    public enum DrivePIDStatus {INIT, RUNNING, DONE, STOPPED, ATEND };
    private DrivePIDStatus mDrivePIDStatus = DrivePIDStatus.INIT;
    private SuperPid mSuperPid = null;				// PID Controller
    
    static public double TGT_STRAIGHT = 0;			// Target Distance
    static public double TGT_STRAIGHT_HDG = 0;		// Target HDG    
    static public double KP_STRAIGHT = 0.076;		// Drive Distance P constant
    static public double KI_STRAIGHT = 0.0;			// Drive Distance I constant	
    static public double KD_STRAIGHT = 0.36;		// Drive Distance D constant
    static public double KF_STRAIGHT = 0.0;			// Drive Distance F constant
    static public double KMAXOUT_STRAIGHT = 1.0;	// Drive Distance F constant
    static public double ABS_TOL_IN = 1.0;
    static public double KDRIFT_STRAIGHT = 0.015;			// Drive Straight P constant
    static public double KMOVERT_STRAIGHT = 3.6;	// Drive Straight MoveRt
    static public double KBBANG_UPPER_STRAIGHT = 0.4;
    static public double KBBANG_LOWER_STRAIGHT = 0.01; 
    

    static public double TGT_ROT = 0;				// Rotation Tgt Angle
    static public double KP_ROT = 0.048;			// Point Turn P constant
    static public double KI_ROT = 0.000;			// Point Turn I constant	
    static private double KD_ROT = 0.14;			// Point Turn D constant
    static public double KF_ROT = 0.000;			// Point Turn F constant
    static public double ROT_MAX_PWR = 0.75;			// PID Min Max Output
    static public double ROT_MOVE_RATE =  3.0;		// PID Setpoint Rate
    static public double ROT_BBANG_UPPER_THRESH = 0.5;
    static public double ROT_BBANG_LOWER_THRESH = 0.1;
    static public double ABS_TOL_DEG = 1.0;
    
    private double mPID_R, mPID_I, mPID_O, mPID_S; 	// Logging data for PID Input, RawOut, Output, Setpoint

    // encoder constants from the part specifications (note they are different leftStats and rightStats)
    //static final private double WHEEL_RADIUS_IN = 2.0;
    //static final private double LEFT_ENCODER_PPR = 360;  	// 1440 ;  
    //static final private double RIGHT_ENCODER_PPR = 250; 	// 1000 ;
    //static final private double LEFT_ENCODER_IN_PER_PULSE = 2.0 * Math.PI * WHEEL_RADIUS_IN / LEFT_ENCODER_PPR;
    //static final private double RIGHT_ENCODER_IN_PER_PULSE = 0.05084746;// might work better than the calc'd
    //static final private double DRIVETRAIN_RADIUS_IN = 11.875;  // robot leftStats/right wheel distance from center

    static final private double WHEELBASE = 25.25;				// Distance between wheels

    // --------- User defined Elements ---------------- 

    public static final int kSlotIdx = 0;
    
    /* Talon SRX/ Victor SPX will supported multiple (cascaded) PID loops.  
        * For now we just want the primary one.
        */
    public static final int kPIDLoopIdx = 0;

    /*
    * set to zero to skip waiting for confirmation, set to nonzero to wait
    * and report to DS if action fails.
    */
    public static final int kTimeoutMs = 10;
    
    // ----------------- Encoder Conversion USED !!!! --------------------------------------------------------
    //private double k_EncConvConst = 0.00462016;		// Talon Magnetic Encoder Conv inches/cnt used in 2018
    //private double k_EncConvConst = 0.00064935;		// Talon Magnetic Encoder Conv inches/cnt used in 2019
    private double k_EncConvConst = 0.00049838;		// Talon Magnetic Encoder Conv inches/cnt used in 2019
    
    
    // -------------------------------------------------------------------------------------------------------
    
    //private double k_LeftEncConvConst =  0.033998;
    //private double k_RightEncConvConst = 0.050035;
    //public static final double kEncoderConvPtTurn = 0.02978;	// avg degrees rotation per encoder cnt.
    //private static final double kMaxSonarConv = 22.0;			// Constant for Inches per volt value
    private String line;
    private static double  displayCtr = 0;      // used to refresh display on every 5 th. cycle ie) 100ms 10x/sec.

    // These gyro correction values may need to be tweaked based on floor type,
    //private static double GYROCORRCNST = 0.400;   // 0.155 maybe lower than ideal??
    private static double GYROCORRLIMIT = 0.000;
    private static double GYROCORRCNST = -0.00;   // 0.155 maybe lower than ideal??

    private double gyroCorrection, gyroCorrectedLeft, gyroCorrectedRight;
    double tgtHdg, lastTgtHdg;
    
    // ---------------------- Drive Statistics ------------------
    private double mCurrGyroYaw ;
    private double motorMode;
    //private String[] motorModeDesc = {"Coasting", "DriveByJoystick", "Arcade", "Straight", "TankDrive", "PID Fwd", 
    //                                    "PID Rotate", "Velocity" , "DualPidToCoord", "Other"};
    private double m_Zone;
    private String[] zoneDesc = {"Coasting", "FwdCmd", "PtTurn", "PID Fwd", "PID Rot", "Joystick", "Fwd2Cmd",
                                "ArcTurn", "Velocity", "Braking", "ArcFollower", "DualPidToCoord", "Other"};	

    private double mTgtDist, mTgtYaw, mTgtDistRemain, mTgtYawRemain ;
    private double mCurrYaw ;

    private double motorLeftPwr, motorRightPwr, motorPwr, motorAngle ;
    
    private double PIDTgtDist, PIDTgtDistRemain, PIDTgtYaw, PIDTgtYawRemain;
    
    public double Field_Position_Startup_X = 0;
    public double Field_Position_Startup_Y = 0;
    public double Field_Position_Startup_O = 0;

    private DriveStats leftStats = new DriveStats();
    private DriveStats rightStats = new DriveStats();
    private DriveStats avgStats = new DriveStats();

    private boolean m_LogFlag, mLogCoastFlag;
    
    // some of the controllers need to know orientation relative to the playfield
    // so we need a record of the absolute orientation when the IMU or position
    // tracker are initialized
    private double mInitialOrientationDegCCW = 0 ; 
    private double mLastGyroYaw = 0;			// Used to calculate gyro rot rate
    private double mYawRate = 0;
    
    // PHS: making the position tracker a full fledged object
    PositionTracker posnTracker ;

    //private double mLastYaw = 0;			// Used to calculate gyro rot rate
    private double mGyroAngleRate = 0;
    //private double mGyroAngleRate2 = 0;
        
    // ---------------------------------------------------------------
    // --- variables to calculate speed and acceleration from encoders
    private double lastTime;

    private double avgVelMinus1, avgVelMinus2, avgVelMinus3;

    // --- For Gearshift valve
    public enum Gear {HI,LO};
    private Gear trans = Gear.HI;

    // ---- Power Distribution Panel Drive motor breaker number assignments
    private static final int LEFT_TOP_MOTOR_BRKR = 1;
    private static final int LEFT_FRONT_MOTOR_BRKR = 2;
    private static final int LEFT_BACK_MOTOR_BRKR = 3;

    private static final int RIGHT_TOP_MOTOR_BRKR = 15;
    private static final int RIGHT_FRONT_MOTOR_BRKR = 14;
    private static final int RIGHT_BACK_MOTOR_BRKR = 13;

    private static final boolean CLIMB_EXTENDED_SWITCH_PRESSED = 	true;
    private static final boolean CLIMB_RETRACTED_SWITCH_PRESSED = 	true;
    private static final double CLIMB_MOTOR_EXTEND_SPEED = -0.8;
    private static final double CLIMB_MOTOR_RETRACT_SPEED = 0.8 ;

    // -------------- Drive Motor Current Limiting ---------------

    private static final int DRIVE_MTR_MAX_PEAK_CURRENT = 25;    // Amps
    private static final int DRIVE_MTR_MAX_PEAK_DURATION = 100;   // Milliseconds
    private static final int DRIVE_MTR_MAX_CONT_CURRENT = 25;    // Amps
    private static final boolean DRIVE_MTR_CURRENT_LIMIT_FLAG = true;

    // ----------- Drivetrain Constructor ------------------------
    public Drivetrain() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
leftFMtr = new WPI_TalonSRX(6);


        
leftRMtr = new WPI_TalonSRX(5);


        
leftTMtr = new WPI_TalonSRX(7);


        
leftMtrGrp = new SpeedControllerGroup(leftRMtr, leftFMtr , leftTMtr );
addChild("leftMtrGrp",leftMtrGrp);

        
rightRMtr = new WPI_TalonSRX(1);


        
rightFMtr = new WPI_TalonSRX(2);


        
rightTMtr = new WPI_TalonSRX(10);


        
rightMtrGrp = new SpeedControllerGroup(rightFMtr, rightRMtr , rightTMtr );
addChild("rightMtrGrp",rightMtrGrp);

        
differentialDrive = new DifferentialDrive(leftMtrGrp, rightMtrGrp);
addChild("Differential Drive",differentialDrive);
differentialDrive.setSafetyEnabled(true);
differentialDrive.setExpiration(0.1);
differentialDrive.setMaxOutput(1.0);

        
compressor = new Compressor(0);
addChild("Compressor",compressor);

        
gearShiftValve = new Solenoid(0, 7);
addChild("gearShiftValve",gearShiftValve);

        
climbRetractSwitch = new DigitalInput(20);
addChild("ClimbRetractSwitch",climbRetractSwitch);

        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    
        compressor.setClosedLoopControl(true);

        //leftFMtr
        leftFMtr.configContinuousCurrentLimit(DRIVE_MTR_MAX_CONT_CURRENT); //  amps
        leftFMtr.configPeakCurrentDuration(DRIVE_MTR_MAX_PEAK_DURATION);    // Millisec
        leftFMtr.configPeakCurrentLimit(DRIVE_MTR_MAX_PEAK_CURRENT);       // Amps
        leftFMtr.enableCurrentLimit(DRIVE_MTR_CURRENT_LIMIT_FLAG);         // Turn on current limiting
        //double curr = leftFMtr.getOutputCurrent();
        //double volt = leftFMtr.getMotorOutputVoltage();

        //leftRMtr
        leftRMtr.configContinuousCurrentLimit(DRIVE_MTR_MAX_CONT_CURRENT); //  amps
        leftRMtr.configPeakCurrentDuration(DRIVE_MTR_MAX_PEAK_DURATION);    // Millisec
        leftRMtr.configPeakCurrentLimit(DRIVE_MTR_MAX_PEAK_CURRENT);       // Amps
        leftRMtr.enableCurrentLimit(DRIVE_MTR_CURRENT_LIMIT_FLAG);         // Turn on current limiting

        //leftTMtr
        leftTMtr.configContinuousCurrentLimit(DRIVE_MTR_MAX_CONT_CURRENT); //  amps
        leftTMtr.configPeakCurrentDuration(DRIVE_MTR_MAX_PEAK_DURATION);    // Millisec
        leftTMtr.configPeakCurrentLimit(DRIVE_MTR_MAX_PEAK_CURRENT);       // Amps
        leftTMtr.enableCurrentLimit(DRIVE_MTR_CURRENT_LIMIT_FLAG);         // Turn on current limiting

        //rightFMtr
        rightFMtr.configContinuousCurrentLimit(DRIVE_MTR_MAX_CONT_CURRENT); //  amps
        rightFMtr.configPeakCurrentDuration(DRIVE_MTR_MAX_PEAK_DURATION);    // Millisec
        rightFMtr.configPeakCurrentLimit(DRIVE_MTR_MAX_PEAK_CURRENT);       // Amps
        rightFMtr.enableCurrentLimit(DRIVE_MTR_CURRENT_LIMIT_FLAG);         // Turn on current limiting

        //rightRMtr
        rightRMtr.configContinuousCurrentLimit(DRIVE_MTR_MAX_CONT_CURRENT); //  amps
        rightRMtr.configPeakCurrentDuration(DRIVE_MTR_MAX_PEAK_DURATION);    // Millisec
        rightRMtr.configPeakCurrentLimit(DRIVE_MTR_MAX_PEAK_CURRENT);       // Amps
        rightRMtr.enableCurrentLimit(DRIVE_MTR_CURRENT_LIMIT_FLAG);         // Turn on current limiting

        //rightTMtr
        rightTMtr.configContinuousCurrentLimit(DRIVE_MTR_MAX_CONT_CURRENT); //  amps
        rightTMtr.configPeakCurrentDuration(DRIVE_MTR_MAX_PEAK_DURATION);    // Millisec
        rightTMtr.configPeakCurrentLimit(DRIVE_MTR_MAX_PEAK_CURRENT);       // Amps
        rightTMtr.enableCurrentLimit(DRIVE_MTR_CURRENT_LIMIT_FLAG);         // Turn on current limiting
 

        //posnTracker = new PositionTracker(this, WHEELBASE) ;
         posnTracker = new PositionTracker(this, WHEELBASE, 
                                                 Field_Position_Startup_X,
                                                 Field_Position_Startup_Y,
                                                 Field_Position_Startup_O);
        initVar(); 								// Initialize variables to zero
        initEncoders();
        resetEncodersAndStats();
        //mTgtYaw = mAHRS.getYaw();
        mTgtYaw = mAHRS.getYaw() + Field_Position_Startup_O ;
        
        differentialDrive.setSafetyEnabled(false);		// possibly remove this line may not be needed
        getGyroPrefs();
    }

    // Initialize variables at construction
    void initVar() {
        m_Zone = 0;
        mTgtDist = 0;
        mTgtDistRemain = 0;
        mTgtYaw = 0 ;
        mTgtYawRemain = 0 ;
        lastTime = 0;
        m_LogFlag = false;
        mLogCoastFlag = false;
        clearPIDdata();
        //posnTracker.init(true);
        posnTracker.init(Field_Position_Startup_X,
                         Field_Position_Startup_Y,
                         Field_Position_Startup_O);
        avgVelMinus1 = 0;
        avgVelMinus2 = 0;
        avgVelMinus3 = 0;
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
        if (trans == Gear.HI) {
            gearShiftValve.set(true);
        } else {
            gearShiftValve.set(false);
        }
        
        calcStats();                    // Calculate current stats for position and speed

        if ( displayCtr % 5 == 0) update_SmartDashboard();      // Update dsiplay every 100 ms
        displayCtr++;

        if 	((m_Zone == 0) && (mLogCoastFlag) && ((rightStats.currVel != 0) || (leftStats.currVel != 0))) {
            // We have motion (Coasting) so log
            logDrivetrain();
        }
    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    // ---------------------------------------------------------------------
    // ----------------- Drive Motor Methods -------------------------------
    // ---------------------------------------------------------------------

    public void driveByJoystick(Double pwr, Double turn) {
    	m_Zone = 5;
        motorMode = 1;
        motorPwr = pwr;
        motorAngle = turn;
        motorPwr = limitPwr(motorPwr);
    	differentialDrive.arcadeDrive(-pwr, turn);
        mLogCoastFlag = false;
    }

    // Drive using leftStats and rightStats values
    public void tankDrive(double leftPwr, double rightPwr) {
        motorMode = 5;
        motorLeftPwr = leftPwr;
        motorLeftPwr = limitPwr(motorLeftPwr);
        motorRightPwr = rightPwr;
        motorRightPwr = limitPwr(motorRightPwr);
        differentialDrive.tankDrive(-motorLeftPwr, -motorRightPwr);
        mLogCoastFlag = true;
    	logDrivetrain();
    }
    
    public void stopMtrs() {
    	m_Zone = 0;
        motorMode = 0;
        motorLeftPwr = 0;
        motorRightPwr = 0;
    	differentialDrive.tankDrive(0, 0);
    }
    
    public double limitPwr(double power) {

        /*
       	// Forward Speed Limit
        if      ((getAverageSpeed() < 10) && (power > 0.5)) power = 0.5;
        else if ((getAverageSpeed() < 20) && (power > 0.6)) power = 0.6;
        else if ((getAverageSpeed() < 30) && (power > 0.7)) power = 0.7;
        else if ((getAverageSpeed() < 40) && (power > 0.8)) power = 0.8;
        else if ((getAverageSpeed() < 50) && (power > 0.9)) power = 0.9;
        */
        return power;
    }

    public void driveArcade(float pwr, float turn) {
        motorMode = 2;
        motorPwr = pwr;
        motorPwr = limitPwr(motorPwr);
        motorAngle = turn;
        differentialDrive.arcadeDrive(-motorPwr, motorAngle);       
        mLogCoastFlag = true;
    	logDrivetrain();
    }

    // Gyro assist straight Drive
    public void driveStraightToHdg(double pwr, double tgtYaw, boolean limitOveride) {
        motorMode = 3;
        mTgtYaw = tgtYaw;
        motorPwr = pwr;
        if (limitOveride == false) motorPwr = limitPwr(motorPwr);
        gyroCorrection = calcArcadeGyroCorrection();
        motorAngle = gyroCorrection;
        differentialDrive.arcadeDrive(-motorPwr, motorAngle);
        mLogCoastFlag = true;
    	logDrivetrain();
    }

    // ---------------------------------------------------------------------
    // ----------------- Climb Methods -------------------------------
    // ---------------------------------------------------------------------
    public boolean isClimbExtended() {
        /*if (climbExtendSwitch.get() == CLIMB_EXTENDED_SWITCH_PRESSED ) {
            return true ;
        }
        else {
            return false ;
        }*/
        return true;
    }

    public boolean isClimbRetracted() {
        if (climbRetractSwitch.get() == CLIMB_RETRACTED_SWITCH_PRESSED) {
            return true ;
        }
        else {
            return false ;
        }

    }

    public void climbExtend() {
     /*   if (!isClimbExtended()) {
            climbMotor.set(CLIMB_MOTOR_EXTEND_SPEED);
        }
        else {
            climbMotor.set(0.0) ;
        }*/
    } 

    public void climbRetract() {
     /*   if (!isClimbRetracted()) {
            climbMotor.set(CLIMB_MOTOR_RETRACT_SPEED);
        }
        else {
            climbMotor.set(0.0) ;
        }*/
    } 

    public void climbStop() {
        //climbMotor.set(0.0) ;
    }

    // ------------------------------------------------------------------------
    // ------------------------------ Pneumatic Methods -----------------------
    public void stopCompressor()        { compressor.stop(); }
    public void startCompressor()       { compressor.start(); }

    public void setGear(Gear gear)      { trans = gear; }
    public void setGearHI()             { trans = Gear.HI; }
    public void setGearLO()             { trans = Gear.LO; }
    public Gear getGear()               { return trans; }

    public boolean isInLowGear() {
        if (trans == Gear.LO)           { return true;  }
        else                            { return false; }
    }

    public boolean isInHigiGear() {
        if (trans == Gear.HI)           { return true;  }
        else                            { return false; }
    }

    // ------------------------------------------------------------------------
    // ------------------------ Encoder Methods -------------------------------
    void initEncoders() {
		leftTMtr.setSensorPhase(true);   
        rightTMtr.setSensorPhase(false);
    }

    public void resetEncodersAndStats() {				// Set Encoders to zero
    	rightTMtr.getSensorCollection().setQuadraturePosition(0, 10);    	
    	leftTMtr.getSensorCollection().setQuadraturePosition(0, 10);
    	
        leftStats.clearStats();
        rightStats.clearStats();
        avgStats.clearStats();
        lastTime = Robot.sysTimer.get();
        //getPIDPrefs();
        //posnTracker.init(false);
        posnTracker.init(Field_Position_Startup_X,
                         Field_Position_Startup_Y,
                         Field_Position_Startup_O);
    }
    
    public void resetPosition(boolean mode) {
    	// Mode true  - Reset to zero position
    	//      false - Sets position to continue next segment
    	resetEncodersAndStats();
        //posnTracker.init(mode);
        posnTracker.init(Field_Position_Startup_X,
                         Field_Position_Startup_Y,
                         Field_Position_Startup_O);    	
    }
  
    public void setFieldPosition(Position newPos) {
    	// Mode true  - Reset to zero position
    	//      false - Sets position to continue next segment
    	//resetEncodersAndStats();
        //posnTracker.init(mode);
        posnTracker.init(newPos.x, newPos.y, newPos.orientCW);
    }
    
    public robot.utils.PositionTracker.Posn getCurrPosition() {
        robot.utils.PositionTracker.Posn posn = posnTracker.getPosition();
    	return posn;
    }
    
    public double getPositionX()            { return avgStats.currXpos; }
    public double getPositionY()            { return avgStats.currYpos; }
    public double getPositionZ()            { return avgStats.currGyroYaw; }
    public double getTrackerYaw()           { return avgStats.mCurrTrackerYaw; }
    
    public int getLeftEncoder() 			{ return leftTMtr.getSelectedSensorPosition(0); }
    public int getRightEncoder()			{ return rightTMtr.getSelectedSensorPosition(0); }

    public int getLeftEncoderVel() 			{ return leftTMtr.getSelectedSensorVelocity(0); }
    public int getRightEncoderVel()			{ return rightTMtr.getSelectedSensorVelocity(0); }    
    
    public double getLeftEncoderDist()		{ return (getLeftEncoder() * k_EncConvConst); }
    public double getRightEncoderDist()		{ return (getRightEncoder() * k_EncConvConst); }
    
    public double getLeftDist()				{ return (leftStats.currDist); }    
    public double getRightDist()			{ return (rightStats.currDist); }    
    
    public double getLeftSpeed()			{ return (leftStats.currVel); }    
    public double getRightSpeed()			{ return (rightStats.currVel); }  
    
    public double getAverageDist()			{ return (avgStats.currDist); }
    public double getAverageSpeed()			{ return (avgStats.currVel); }
    public double getRunningAverageVelocity() { return (avgStats.runningAvgVelocity); }

    public void setXBoxLeftMode(){
        xBoxLRMode = XBoxLRMode.LEFT;
    }

    public void setXBoxRightMode(){
        xBoxLRMode = XBoxLRMode.RIGHT;
    }

    public boolean isXboxModeLeft(){
        if (  xBoxLRMode == XBoxLRMode.LEFT) return true;
        return false;
    } 

    public boolean isXboxModeRight(){
        if (  xBoxLRMode == XBoxLRMode.RIGHT) return true;
        return false;
    } 
    // ------------- Drivertrain Statistics Methods ---------------
    // ------------- Speed and Distance Methods -----------------  
    void calcStats() {
        double time;
        int    leftEncoder, rightEncoder, avgEncoder ;
        double leftEncDist, rightEncDist, avgEncDist;
        double deltaTime;

        time = Robot.sysTimer.get();
        deltaTime = time - lastTime;
        lastTime = time;
        if (deltaTime == 0) {
            deltaTime = 0.00000001;			// prevent divide by zero error
        }
        
        // Calculate Gyro rotation rate 
        mCurrGyroYaw = getGyroYaw();
        double deltaAngle = mLastGyroYaw - mCurrGyroYaw;
        mLastGyroYaw = mCurrGyroYaw;
        mYawRate = deltaAngle / deltaTime;

        // encoder values
        leftEncoder = getLeftEncoder();
        rightEncoder = getRightEncoder();        
        avgEncoder = (leftEncoder + rightEncoder) / 2;

        //leftStats.lastEncoder = leftStats.currEncoder;
        leftStats.currEncoder = leftEncoder;

        //rightStats.lastEncoder = rightStats.currEncoder;
        rightStats.currEncoder = rightEncoder;

        //avgStats.lastEncoder = avgStats.currEncoder;
        avgStats.currEncoder = avgEncoder;

        // encoder distances
        leftEncDist = getLeftEncoderDist();
        rightEncDist = getRightEncoderDist();        
        avgEncDist = (leftEncDist + rightEncDist) / 2;
        
        leftStats.lastDist = leftStats.currDist;
        leftStats.currDist = leftEncDist;
        leftStats.currVel = (leftStats.currDist - leftStats.lastDist) / deltaTime;

        rightStats.lastDist = rightStats.currDist;
        rightStats.currDist = rightEncDist;
        rightStats.currVel = (rightStats.currDist - rightStats.lastDist) / deltaTime;

        avgStats.lastDist = avgStats.currDist;
        avgStats.currDist = avgEncDist;
        avgStats.currVel = (rightStats.currVel + leftStats.currVel) / 2;

        // Update running average velocity
        avgStats.runningAvgVelocity = (avgStats.currVel + avgVelMinus1 + avgVelMinus2 + avgVelMinus3) / 4;
        
        // Update historical average velocities
        avgVelMinus3 = avgVelMinus2;
        avgVelMinus2 = avgVelMinus1;
        avgVelMinus1 = avgStats.runningAvgVelocity;

        //  ---Calculate Robot position on field---        
        posnTracker.updatePositions() ;
        robot.utils.PositionTracker.Posn posn = posnTracker.getPosition() ;
        avgStats.currXpos=posn.x;
        avgStats.currYpos=posn.y;
        avgStats.mCurrTrackerYaw = posn.yaw;
        avgStats.currGyroYaw = mCurrGyroYaw ; 

        //  ---Calculate Robot position on field--- 
        //leftStats.currentTMtr = Robot.pdp.getCurrent(LEFT_TOP_MOTOR_BRKR);
        //leftStats.currentFMtr = Robot.pdp.getCurrent(LEFT_FRONT_MOTOR_BRKR);
        //leftStats.currentBMtr = Robot.pdp.getCurrent(LEFT_BACK_MOTOR_BRKR);

        //rightStats.currentTMtr = Robot.pdp.getCurrent(RIGHT_TOP_MOTOR_BRKR);
        //rightStats.currentFMtr = Robot.pdp.getCurrent(RIGHT_FRONT_MOTOR_BRKR);
        //rightStats.currentBMtr = Robot.pdp.getCurrent(RIGHT_BACK_MOTOR_BRKR);

        //avgStats.currentAVG = Robot.pdp.getTotalCurrent();
        //avgStats.voltage = Robot.pdp.getVoltage();
    }

    // ----------------------- Zone Data, Distance to Go ------------------------------------------
    public void putZoneData(int zone, double tgtDist, double tgtDistRemain, double tgtYaw, double tgtYawRemain) {
        m_Zone = zone;
        mTgtDist = tgtDist;
        mTgtDistRemain = tgtDistRemain;
        mTgtYaw = tgtYaw ;
        mTgtYawRemain = tgtYawRemain ;
    }

    double getZone()			{ return m_Zone; }
    double getTgtDist() 		{ return mTgtDist; }
    double getTgtDistRemain()	{ return mTgtDistRemain; }
    double getTgtYaw() 			{ return mTgtYaw; }
    double getTgtYawRemain()	{ return mTgtYawRemain; } 
    double getYawRate()         { return mYawRate; }   
    
    // -----------------------------------------------------------------------
    // ----------------------------- Gyro Routines ---------------------------
    void gyroInit() {
        //gyro.SetDeadband( 0.015);						// may need to play with this value
        //gyro.SetSensitivity(0.007);					// used with analog gyro
    }

    public void resetGyro() {
        //mAHRS.zeroYaw();
        mAHRS.reset();
        System.out.println("Gyro has reset");
    }

    public double getGyroHeading() {
        //double hdg = mAHRS.getYaw();
        double hdg = mAHRS.getYaw() + Field_Position_Startup_O;
        if (hdg < 0) { hdg += 360; }
        return hdg;
    }

    public double getGyroYaw() 	{
        //return mAHRS.getYaw();
        return mAHRS.getYaw() + Field_Position_Startup_O;
    }

    public double getGyroYawRate() { 
        // return mAHRS.getRate();			// tis doesnt seem to be working ???
        //mGyroAngleRate2 = mAHRS.getRate() / mAHRS.getLastSensorTimestamp();
    	return mGyroAngleRate;
    }

    // ----------------- Calculate Correction ----------------------------------------
    double calcArcadeGyroCorrection() {
        mCurrYaw = getGyroYaw();
        double yawerr = mTgtYaw - mCurrYaw;
        if (yawerr > 180)  { yawerr -= 360; }
        if (yawerr < -180) { yawerr += 360; }
        double correctionValue = yawerr * GYROCORRCNST;
        // -- Test for exceeding limits --
        if (correctionValue < 0) {
            if (correctionValue < (-GYROCORRLIMIT)) {
                correctionValue = -GYROCORRLIMIT;
            }
        } else if (correctionValue > GYROCORRLIMIT) {
            correctionValue = GYROCORRLIMIT;
        }
        gyroCorrection = correctionValue;							// For Logging purposes
        if (Math.abs(motorPwr) < 0.2) {
        	// correct for over powering at low speeds
        	gyroCorrection = gyroCorrection * 0.5;
        }
        return correctionValue;
    }

    double calcTankGyroCorrection(double pwrOut, double drift) {
        mCurrYaw = getGyroYaw();
        double yawerr = mTgtYaw - mCurrYaw;
        if (yawerr > 180)  { yawerr -= 360; }
        if (yawerr < -180) { yawerr += 360; }
        
        gyroCorrectedLeft = pwrOut * (1 - yawerr * drift);
        gyroCorrectedRight = pwrOut * (1 + yawerr * drift);
        // make sure the larger drive magnitude isn't bigger than 1
        double max = Math.max(Math.abs(gyroCorrectedLeft), Math.abs(gyroCorrectedRight));
        if (max > 1) {
            gyroCorrectedLeft  = gyroCorrectedLeft  / max;
            gyroCorrectedRight = gyroCorrectedRight / max;
        }
        return yawerr;
    }


    // ------------------------------------------------------------------------
    // ------------------------ Roborio Preferences Methods -----------------------
    public void getPIDPrefs() {
        // grab the relevant coefficients from the smart dashboard
        TGT_STRAIGHT = Robot.prefs.getDouble("Drive_10_PID_Fwd_Tgt", TGT_STRAIGHT);
        TGT_STRAIGHT_HDG = Robot.prefs.getDouble("Drive_10_PID_Fwd_Hdg", TGT_STRAIGHT_HDG);
        KP_STRAIGHT = Robot.prefs.getDouble("Drive_11_PID_Fwd_P", KP_STRAIGHT);
        KI_STRAIGHT = Robot.prefs.getDouble("Drive_12_PID_Fwd_I", KI_STRAIGHT);
        KD_STRAIGHT = Robot.prefs.getDouble("Drive_13_PID_Fwd_D", KD_STRAIGHT);
        KF_STRAIGHT = Robot.prefs.getDouble("Drive_14_PID_Fwd_F", KF_STRAIGHT);
        KMAXOUT_STRAIGHT = Robot.prefs.getDouble("Drive_15_PID_Fwd_MaxOut", KMAXOUT_STRAIGHT);
        ABS_TOL_IN = Robot.prefs.getDouble("Drive_16_PID_Fwd_Tol_In", ABS_TOL_IN);
        KDRIFT_STRAIGHT = Robot.prefs.getDouble("Drive_17_PID_fwd_Drift", KDRIFT_STRAIGHT);
        KMOVERT_STRAIGHT = Robot.prefs.getDouble("Drive_18_PID_Fwd_MoveRt",KMOVERT_STRAIGHT);        
        KBBANG_UPPER_STRAIGHT = Robot.prefs.getDouble("Drive_19_PID_Fwd_BB_Lwr",KBBANG_UPPER_STRAIGHT);
        KBBANG_UPPER_STRAIGHT = Robot.prefs.getDouble("Drive_19_PID_Fwd_BB_Upr",KBBANG_UPPER_STRAIGHT);     

        TGT_ROT = Robot.prefs.getDouble("Drive_20_PID_Rot_Tgt", TGT_ROT);
        KP_ROT = Robot.prefs.getDouble("Drive_21_PID_Rot_P", KP_ROT);
        KI_ROT = Robot.prefs.getDouble("Drive_22_PID_Rot_I", KI_ROT);
        
        KD_ROT = Robot.prefs.getDouble("Drive_23_PID_Rot_D", KD_ROT);
        KF_ROT = Robot.prefs.getDouble("Drive_24_PID_Rot_F", KF_ROT);
        ROT_MAX_PWR = Robot.prefs.getDouble("Drive_25_PID_Rot_MaxOut", ROT_MAX_PWR);
        ABS_TOL_DEG = Robot.prefs.getDouble("Drive_26_PID_Tol_Deg", ABS_TOL_DEG);
        ROT_BBANG_LOWER_THRESH = Robot.prefs.getDouble("Drive_30_PID_Rot_BB_Lwr", ROT_BBANG_LOWER_THRESH);
        ROT_BBANG_UPPER_THRESH = Robot.prefs.getDouble("Drive_31_PID_Rot_BB_Upr", ROT_BBANG_UPPER_THRESH);
        ROT_MOVE_RATE = Robot.prefs.getDouble("Drive_32_PID_Rot_MoveRt", ROT_MOVE_RATE);
    }
    
    public void getGyroPrefs() {
        // grab the relevant data from the smart dashboard
        GYROCORRCNST =Robot.prefs.getDouble("Drive_50_GyroCor", GYROCORRCNST);
        GYROCORRLIMIT =Robot.prefs.getDouble("Drive_51_GyroMax", GYROCORRLIMIT);
    }


    // ------------------------------------------------------------------------
    // ------------------------ Smart Dashboard Methods -----------------------
    void update_SmartDashboard() {
        SmartDashboard.putNumber("Enc-Left Cnt", Rmath.mRound(leftStats.currEncoder, 2));
        SmartDashboard.putNumber("Enc-Left Dist", Rmath.mRound(leftStats.currDist, 2));
        SmartDashboard.putNumber("Enc-Right Cnt", Rmath.mRound(rightStats.currEncoder, 2));
        SmartDashboard.putNumber("Enc-Right Dist", Rmath.mRound(rightStats.currDist, 2));
        SmartDashboard.putNumber("Drivetrain Average Distance", Rmath.mRound(avgStats.currDist, 2));
        SmartDashboard.putNumber("Drivetrain Average Speed", Rmath.mRound(avgStats.currVel, 2));
        
        SmartDashboard.putNumber("Rbt X Pos", Rmath.mRound(avgStats.currXpos, 2));
        SmartDashboard.putNumber("Rbt Y Pos", Rmath.mRound(avgStats.currYpos, 2));
        SmartDashboard.putNumber("Rbt Angle", Rmath.mRound(avgStats.mCurrTrackerYaw, 2));
        SmartDashboard.putNumber("Gyro-Yaw", Rmath.mRound(getGyroYaw(), 2));
        SmartDashboard.putNumber("Gyro-Yaw-Rt", Rmath.mRound(getGyroYawRate(), 2));
        SmartDashboard.putNumber("Gyro-Hdg", Rmath.mRound(getGyroHeading(), 2));
        SmartDashboard.putNumber("Posn-Yaw", Rmath.mRound(avgStats.mCurrTrackerYaw,2)) ;

        SmartDashboard.putNumber("L Enc Cnt", Rmath.mRound(getLeftEncoder(), 3));
        SmartDashboard.putNumber("R Enc Cnt", Rmath.mRound(getRightEncoder(), 3));
        SmartDashboard.putNumber("L Enc Vel", Rmath.mRound(leftStats.currVel, 3));
        SmartDashboard.putNumber("R Enc Vel", Rmath.mRound(rightStats.currVel, 3));

        if (trans == Gear.HI) {
            SmartDashboard.putString("Gear", "High Gear");
        }
    	else {
            SmartDashboard.putString("Gear", "Low Gear");
        }
        
        SmartDashboard.putNumber("Left_F_Mtr Curr",Rmath.mRound(leftStats.currentFMtr, 3));
        SmartDashboard.putNumber("Left_B_Mtr Curr",Rmath.mRound(leftStats.currentBMtr, 3));
        SmartDashboard.putNumber("Left_T_Mtr Curr",Rmath.mRound(leftStats.currentTMtr, 3));

        SmartDashboard.putNumber("Right_F_Mtr Curr",Rmath.mRound(rightStats.currentFMtr, 3));
        SmartDashboard.putNumber("Right_B_Mtr Curr",Rmath.mRound(rightStats.currentBMtr, 3));
        SmartDashboard.putNumber("Right_T_Mtr Curr",Rmath.mRound(rightStats.currentTMtr, 3));

        SmartDashboard.putNumber("Avg_Mtr Curr",Rmath.mRound(avgStats.currentAVG, 3));

        if      ( Robot.robotPosState == Robot.RobotPosState.TRAVEL)
                              SmartDashboard.putString("Robot State", "TRAVEL POS.");
        else if ( Robot.robotPosState == Robot.RobotPosState.EJECT_MAIN)
                              SmartDashboard.putString("Robot State", "EJECT_MAIN POS.");
        else if ( Robot.robotPosState == Robot.RobotPosState.EJECT_ROCKET_MID)
                              SmartDashboard.putString("Robot State", "EJECT_ROCKET_MID POS.");
        else if ( Robot.robotPosState == Robot.RobotPosState.EJECT_ROCKET_HIGH)
                              SmartDashboard.putString("Robot State", "EJECT_ROCKET_HIGH POS.");
        else if ( Robot.robotPosState == Robot.RobotPosState.EJECT_HATCH_FWD)
                              SmartDashboard.putString("Robot State", "EJECT_HATCH_FWD POS.");
        else if ( Robot.robotPosState == Robot.RobotPosState.RETREIVE_CARGO)
                              SmartDashboard.putString("Robot State", "RETREIVE_CARGO POS.");
        else if ( Robot.robotPosState == Robot.RobotPosState.RETREIVE_HATCH_FLOOR)
                              SmartDashboard.putString("Robot State", "RETREIVE_HATCH_FLOOR POS.");
        else if ( Robot.robotPosState == Robot.RobotPosState.RETREIVE_HATCH_LS)
                              SmartDashboard.putString("Robot State", "RETREIVE_HATCH_LS POS.");

        if (isClimbExtended())
            SmartDashboard.putString("Climb Extended", "PRESSED");
        else
            SmartDashboard.putString("Climb Extended", "NOT PRESSED");
        if (isClimbRetracted())
            SmartDashboard.putString("Climb Retracted", "PRESSED");
        else
            SmartDashboard.putString("Climb Retracted", "NOT PRESSED");
    }
    
    private void clearPIDdata() {
        mPID_I = 0 ;
        mPID_R = 0 ;
        mPID_O = 0 ;
        mPID_S = 0 ;    	
    }


    public void clearPositionData(boolean flag){
        //posnTracker.init(flag);
        posnTracker.init(Field_Position_Startup_X,
                         Field_Position_Startup_Y,
                         Field_Position_Startup_O);
    }
    
    public void setLoggingOn()	{ m_LogFlag = true; }
    public void setLoggingOff() { m_LogFlag = false; }

    // ----------- Log Drivetrain data --------------------
    public void logDrivetrain() {

    	// ----------- Check to see if we should just exit and not log ----------------
        if (m_LogFlag == false) { return; }						                // Do not log travel data
        if ((rightStats.currVel == 0) && (leftStats.currVel == 0)) { return; }	// No motion so don't log
        // ---------- Build Print String -----------------
        line = "";
        // ---------- Show Zone Description ------------
        if ((m_Zone >=  0) && (m_Zone <= 11)) {
        	line += zoneDesc[(int) m_Zone] ;
        } else {
        	line += zoneDesc[12] ;		// Other
        }

        // ------------ Show Current/Remain Dist and Yaw ------------
        line += ", Dist C/R=," + Rmath.mRound(avgStats.currDist,2) + "," + Rmath.mRound(getTgtDistRemain(),2) ;
        line += ", Yaw C/R=," +  Rmath.mRound(mCurrYaw,2) + "," + Rmath.mRound(getTgtYawRemain(),2) ;
        line += " ,Gyro Rt=," +  Rmath.mRound(getGyroYawRate(),2);        

        // ---------- Show Robot Position data as calculated from left/right encoder distances
        line += " ,Pos XYAO=,"
        + Rmath.mRound(avgStats.currXpos,2) + ","
        + Rmath.mRound(avgStats.currYpos,2) +  ","
        + Rmath.mRound(avgStats.mCurrTrackerYaw,2) + ","
        + Rmath.mRound(getOrientDegCCW(),2) ;
        
        // ------------ Show current motor pwr ------------
        if ((m_Zone == 0) || (m_Zone == 1) || (m_Zone == 4) || (m_Zone == 7) ||
                            (m_Zone == 9) || (m_Zone == 11))  {
        	line += ",Pwr L/R=," + motorLeftPwr  + "," + motorRightPwr ; 
    	} else {
        	line += ",Pwr/Dir=," + motorPwr + "," + motorAngle ; 
        }

        // ------------ Show motor current draw and voltage ------------
        line += ",LeftTFB=," + Rmath.mRound(leftStats.currentTMtr, 3) +
                         "," + Rmath.mRound(leftStats.currentFMtr, 3) +
                         "," + Rmath.mRound(leftStats.currentBMtr, 3);
        line += ",RightTFB=," + Rmath.mRound(rightStats.currentTMtr, 3) +
                        "," + Rmath.mRound(rightStats.currentFMtr, 3) +
                        "," + Rmath.mRound(rightStats.currentBMtr, 3);
        line += ",Avg Cur&Volt=," + Rmath.mRound(avgStats.currentAVG, 3) +
                        "," + Rmath.mRound(avgStats.voltage, 3);

        // ---------- Show Distance Left/Right for robot ----------
        line += " ,Dist LR=," + Rmath.mRound(leftStats.currDist,3) + ","
                                + Rmath.mRound(rightStats.currDist,3);
                                
        // ------------ Gear Status ------------
        if (trans == Gear.LO) {
            line += " ,Gear=,LO,";
        } else {
            line += " ,Gear=,HI,";
        }
        
        // ---------- Show Speed and Acceleration data for robot ----------
        line += " ,Speed ALR=," + Rmath.mRound(avgStats.currVel,2) + ","
        						+ Rmath.mRound(leftStats.currVel,2) + ","
                                + Rmath.mRound(rightStats.currVel,2);
        line += " ,Running VEL=," + Rmath.mRound(avgStats.runningAvgVelocity,2);                     
        line += " ,Accel=," + Rmath.mRound(avgStats.currAccel,2) ;

        // ------------ Show PID Data ------------
        if (( m_Zone == 3) || ( m_Zone== 4)) {
        	line += ",PID IROS=," + mPID_I + "," + mPID_R + "," + mPID_O + "," + mPID_S ;
        } else if (m_Zone == 8) {
        	line += ",PID RL=," + mPID_R + "," + mPID_O ;
        } else if (m_Zone == 11) {
            // cndDualPidToCoordCmd
            line += ",Dist to Tgt=," + mTgtDist + ",DistCtl=," + mTgtDistRemain + 
                    ",BearingToTgt=," + mTgtYaw + ",BearingCtl," + mTgtYawRemain ;    
        }
        
        // ---- send line to Logger ---------
        Robot.logger.appendLog(line);
    }

        /*****************************
     * Interface Methods for the LineFollowController
     * (and the ...ToXY Commands)
     */

	// NOTE
	// There may be a temptation to convert all the ft stuff
	// to inches. I recommend against that because the KP, KD, and KI
	// PID parameters depend on units. When changing units they
	// equivalents can of course be calculated, but I do simulation
	// in feet because it is easier, and get's me pretty close to
	// actual values, so why risk introducing a bug if you don't 
	// need to, because inches can easily be converted to feet
	// on the fly, which is what you see here
	public double getXinFt()                { return getPositionX()/12.0 ; }
	public double getYinFt()                { return getPositionY()/12.0 ; }
    public void   setInitialOrientationDegCCW(double orient) { mInitialOrientationDegCCW = orient ; }
	public double getVelocityInFtPerSec()   {	return getAverageSpeed()/12.0 ;	}
	public double getRotationVelocityInDegreesCWperSec() { return getGyroYawRate() ; }
	public double getOrientDegCCW() {
		// return (mInitialOrientationDegCCW - mCurrGyroYaw) ;
		
		// TODO: I haven't tested this but am convinced
		// by the trial runs that it is better
		// (but may mean some feedback parameter returning
		return (mInitialOrientationDegCCW - getTrackerYaw()) ;
	}


    public void logPIDStraightPrefs() {
        line = "***** PID Drivetraight Command - PID Values ";
        line += "  KP=" + KP_STRAIGHT;
        line += "  KI=" + KI_STRAIGHT;
        line += "  KD=" + KD_STRAIGHT;
        line += "  KF=" + KF_STRAIGHT;
        line += "  MaxOut=" + KMAXOUT_STRAIGHT;
        line += "  TOL_IN=" + ABS_TOL_IN;
        line += "  DRIFT=" + KDRIFT_STRAIGHT;
        line += "  MOVE RATE=" + KMOVERT_STRAIGHT;
        line += "  *****";
        // ---- send line to Logger ---------
        Robot.logger.appendLog(line);
    }

    public void logPIDRotatePrefs() {
        line = "***** PID Drive Rotate Command - PID Values ";
        line += "  TGT_ROT," + TGT_ROT;
        line += "  KP," + KP_ROT;
        line += "  KI," + KI_ROT;
        line += "  KD," + KD_ROT;
        line += "  KF," + KF_ROT;
        line += "  MaxOut," + ROT_MAX_PWR;
        line += "  Rot.MoveRt," + ROT_MOVE_RATE;                
        line += "  TOL_IN," + ABS_TOL_DEG;
        line += "  BB_LWR_THRESH=" + ROT_BBANG_LOWER_THRESH;
        line += "  BB_UPR_THRESH=" + ROT_BBANG_UPPER_THRESH;
        line += "  *****";        
        // ---- send line to Logger ---------
        Robot.logger.appendLog(line);
    }
    

    // ********************************************************************************
    //                      PID METHODS AND CLASS 
    // ********************************************************************************
    // Drive straight using a PID for a given distance
    public void driveStraightPid(double distance, double tgtYaw) {
    	stopPID();												// In case previous Pid still in operation
    	motorMode = 6;
        mDriveMode = DriveMode.AUTO_STRAIGHT;					// record that we're in PID mod
        PIDTgtYaw = tgtYaw ;
        getPIDPrefs();											// Get PID Constant data
        getGyroPrefs();											// Get Update Gyro COnstants
        if (distance == 999) {
            PIDTgtDist = TGT_STRAIGHT;
            PIDTgtYaw = TGT_STRAIGHT_HDG;
        } else {
        	PIDTgtDist = distance;
        } 
      	line = "***** Entering PID driveStraight    Distance =" + PIDTgtDist + "  PIDTgtYaw=" + PIDTgtYaw +" ******";
        System.out.println(line);
        Robot.logger.appendLog(line);
        logPIDStraightPrefs();
        mSuperPid = new DistancePid(PIDTgtDist, KP_STRAIGHT, 0, KD_STRAIGHT, KF_STRAIGHT);
        resetEncodersAndStats();										// reset the encoder counts
        mDrivePIDStatus = DrivePIDStatus.RUNNING;
        mSuperPid.start();										// start the PID IO (and the PID)
    } 
    
    // Drive Point turn using a PID for a given angle of rotation
    public void pidRotateTo(double angleDeg) {
    	stopPID();												// In case previous Pid still in operation
        motorMode = 7;
        mDriveMode = DriveMode.AUTO_ROTATE;
        getPIDPrefs();											// Get PID Constant data
        if (angleDeg == 999) {
            PIDTgtYaw = TGT_ROT;	        	
        } else {
        	PIDTgtYaw = angleDeg;
        }
        PIDTgtDist = 0;				// point turn has no distance
      	line = "***** Entering PID Rotate - PIDTgtYaw=" + PIDTgtYaw +" ******";
        System.out.println(line);
        Robot.logger.appendLog(line);
        logPIDRotatePrefs();
        System.out.println("PID D=" + KD_ROT);
        mSuperPid = new RotationPid(PIDTgtYaw, KP_ROT, 0, KD_ROT, KF_ROT);	// create PID controller
        //m_TgtAngleRemain = degrees;
        mDrivePIDStatus = DrivePIDStatus.RUNNING;
        mSuperPid.start();
    }

    // a Command can call this to force a stop (e.g., from a watchdog timer)    
    public void stopPID() {
        // stop the drive motors and shutdown automation
    	line = "****** STOPPING PID AUTOMATION (stopPID() was Called) *****";
        //System.out.println(line);
        Robot.logger.appendLog(line);
        if (mSuperPid != null) {
        	mSuperPid.stop();			
        }
        mDriveMode = DriveMode.TELE;
        mDrivePIDStatus = DrivePIDStatus.STOPPED;
        stopMtrs();						// The pid never sends a stop .. so motor continues running
        Robot.drivetrain.putZoneData(0, 0.0, 0.0, 0.0, 0.0);					// Stop logging distance to tgt
    }

    // 	***********  PID Routines  ******************    
    // a Command can call this to see what mode were in
    public DriveMode getDriveMode() { 
    	return mDriveMode;
    }
    
    // a Command can call this to see if we're done
    public DrivePIDStatus getDrivePIDStatus() { 
    	return mDrivePIDStatus;
    }    

    
    // --------------------------------------------------------------------------------
    //                       Inner DISTANCE PID CLASS
    // --------------------------------------------------------------------------------

    private class DistancePid extends SuperPid { 
        //int mLogCounter = 0; 
        // constructor
        public DistancePid(double distance, double Kp, double Ki, double Kd, double Kf) {
            super(distance, Kp, Ki, Kd, Kf);
            mOptions.setKeepRunningCriteria(true, distance * .01 );
            mOptions.setRamping(true, KMOVERT_STRAIGHT);							// use ramping
            //mOptions.setOutputRange(KMAXOUT_STRAIGHT, -KMAXOUT_STRAIGHT); 	// Limit output (speed)
            if (distance > 96) {
            	mOptions.setOutputRange(0.8, -0.8); 	// Limit output (speed)
            } else if ( distance >= 20) {
            	mOptions.setOutputRange(0.75, -0.75); 	// Limit output (speed)
            } else {
            	mOptions.setOutputRange(0.7, -0.7); 	// Limit output (speed)
            }
            
            //mOptions.setBangBang(true, KBBANG_UPPER_STRAIGHT, KBBANG_LOWER_STRAIGHT);
            mOptions.setBangBang(false, 0, 0);
        }

        @Override
        public void applyPidOutput(double output) {
        	motorPwr = limitPwr(output);
        	motorAngle = calcArcadeGyroCorrection();
            // if (mLogCounter == 0) {  System.out.println("*** gyroCorrection=" + motorAngle;  }
            // mLogCounter = (mLogCounter + 1) % 5;
        	PIDTgtYawRemain = PIDTgtYaw - getGyroYaw();
            differentialDrive.arcadeDrive(motorPwr, motorAngle);
            putZoneData(3, PIDTgtDist, PIDTgtDistRemain, PIDTgtYaw, PIDTgtYawRemain);	// PIDremain calc in getPidInput
            mLogCoastFlag = true;
            logDrivetrain();
            
        }

        @Override
        public double getPidInput() {
            PIDTgtDistRemain = PIDTgtDist - getAverageDist();					 // these are in inches
            // consider testing for termination condition here such as velocity is almost zero 
            // such as maybe we hit something. or we just don't have enough correction pwr to continue
            return getAverageDist();
        }

        @Override
        public void updatePidStatus(SuperPid.PidStatus status, double input, double rawOutput, double pidOut,  double setpoint ) {
            //Robot.logger.appendLog(" AN update of Fwd PIDStatus has been received PidStatus=" + status );
            if (status == PidStatus.RUNNING) {
                mDrivePIDStatus = DrivePIDStatus.RUNNING;
                mPID_I = input ;
                mPID_R = rawOutput ;
                mPID_O = pidOut ;
                mPID_S = setpoint ;
                return;
            } else if (status == PidStatus.STOPPED) {
            	Robot.logger.appendLog(" AN update of Fwd PIDStatus has been received PidStatus=" + status );
                mDriveMode = DriveMode.DONE;
                mDrivePIDStatus = DrivePIDStatus.STOPPED;
                clearPIDdata();
                stopMtrs();						// The pid never sends a stop .. so motor continues running
                return;
            } else if (status == PidStatus.ATEND) {
            	Robot.logger.appendLog(" AN update of Fwd PIDStatus has been received PidStatus=" + status );
                mDrivePIDStatus = DrivePIDStatus.ATEND;
                mDriveMode = DriveMode.DONE;            	
            	// consider testing for termination condition here such as
                return;
            }
        }
    }

    // ********************************************************************************
    //                      PID ROTATION METHODS AND CLASS 
    // ********************************************************************************
 
    // --------------------------------------------------------------------------------
    //                       Inner Rotation PID CLASS
    // --------------------------------------------------------------------------------
    private class RotationPid extends SuperPid {
        //private double mTargetDeg;
        public RotationPid(double degrees, double Kp, double Ki, double Kd, double Kf) {
            super(validateDeg(degrees), Kp, Ki, Kd, Kf);
            mOptions.setKeepRunningCriteria(false, 1);
            mOptions.setBangBang(true, ROT_BBANG_UPPER_THRESH, ROT_BBANG_LOWER_THRESH);
            mOptions.setInputWrap(true, -180, +180);
            mOptions.setRamping(false, 4);
            mOptions.setOutputRange(ROT_MAX_PWR, -ROT_MAX_PWR); 	// Limit output (speed)
        }

        @Override
        public void applyPidOutput(double output) {
            motorLeftPwr = output;
            motorRightPwr = -output;
            differentialDrive.tankDrive(motorLeftPwr, motorRightPwr);
            putZoneData(4, 0 , 0, mTgtYaw, PIDTgtYawRemain);
            mLogCoastFlag = true;
            logDrivetrain();
        }

        @Override
        public double getPidInput() {
        	mCurrYaw = getGyroYaw();			// Update for logging
        	PIDTgtYawRemain = PIDTgtYaw - mCurrYaw;
            return mCurrYaw;
        }

        @Override
        public void updatePidStatus(SuperPid.PidStatus status, double input, double rawOutput, double pidOut, double setpoint ) {
            if (status == PidStatus.RUNNING) {
            	mDrivePIDStatus = DrivePIDStatus.RUNNING ;
                mPID_I = input ;
                mPID_R = rawOutput ;
                mPID_O = pidOut ;
                mPID_S = setpoint ;
            } else if (status == PidStatus.STOPPED) {
                Robot.logger.appendLog(" AN update of ROT PIDStatus has been received PidStatus=" + status );
                // The PID is done (Stopped) because of end of travel (we reached Setpoint)
                mDrivePIDStatus = DrivePIDStatus.STOPPED;
                mDriveMode = DriveMode.DONE;
                clearPIDdata();
                stopMtrs();						// The pid never sends a stop .. so motor continues running
            } else if (status == PidStatus.ATEND) {
            	// The PID is at the end but no stopping has been set
                // consider testing for termination condition here such as
                // 1. Timer - when distance is within tolerance start timer and after 0.25 seconds end run
                // 2. Look at velocity and when in tolerance zone if velocity is less than ~5 inches per sec. end run
                // stop based on rate
                Robot.logger.appendLog(" AN update of ROT PIDStatus has been received PidStatus=" + status );
            	mDrivePIDStatus = DrivePIDStatus.ATEND ;
            }  
        }
    }

    // ------- Limit degrees -------
    private double validateDeg(double deg) {
        if (deg > 180) {
            deg = 180;
        }
        if (deg < -180) {
            deg = -180;
        }
        return deg;
    }  

    
    // *****************************************************************************
    // Inner CLASS to store data for leftStats, rightStats, average motor statistics
    // *****************************************************************************
    private class DriveStats {
        int    currEncoder;
        double currDist, lastDist;
        double currVel;
        double runningAvgVelocity;
        double currAccel;
        double currXpos, currYpos;
        double currGyroYaw, mCurrTrackerYaw;
        double voltage;
        double currentFMtr, currentTMtr, currentBMtr, currentAVG; 

        public DriveStats() {       // Constructor
            clearStats();
        }

        public void clearStats() {
            currEncoder = 0 ; 
            currDist = lastDist = 0;
            currVel = currAccel = 0;
            currXpos = currYpos = 0;
            mCurrTrackerYaw = currGyroYaw = 0 ;
            runningAvgVelocity = 0;
            voltage = 0;
            currentFMtr =  currentTMtr = currentBMtr = currentAVG = 0;
        }
    }
}
